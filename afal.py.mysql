#!/usr/bin/python
import sys
import mysql.connector
from mysql.connector import errorcode
import random

############################## begin startup code here


config = {
	'database':'afal', 'user':'afal'
, 'password':'BuffyStewart'
}
#try :
conn = mysql.connector.connect(**config)
#except :
#    raise NameError("Database afal or user afal not found")
cur = conn.cursor()

party = 9
first_real_char = 10

######## Cleanup and misc code

def fini() :
    """finish things up and close the database"""
    conn.commit()
    cur.close()
    conn.close()


######## File IO and parsing

def nextline(f):
    if nextline.line:
        ret = nextline.line
        nextline.line = None
        return ret
    ret = ''
    while True:
        tmp = f.readline()
        if len(tmp) < 1:
            break
        if tmp[0] == '#':
            continue
        if tmp[-1] == '\n':
            tmp = tmp[:-1]
            if len(tmp) < 1:
                break
        if tmp[-1] != '\\':
            ret += tmp
            break
        ret += tmp[:-1]
    return ret

nextline.line = None

def pushline(line):
    if nextline.line:
        raise NameError("Line already pushed")
    nextline.line = line

def peekline(file):
    line = nextline(file)
    pushline(line)
    if line == '':
        return '\n'
    return line

def add_entries(d,line):
    while line[0] == ' ':
        line = line[1:]
    h1 = ''
    while len(line) > 0:
        if ';' in line:
            sep = line.index(';')
            if sep > 0 and line[sep-1] == '\\':
                h1 += line[0:sep-1] + ';'
                line = line[sep+1:]
                continue
            hdr = h1 + line[0:sep]
            line = line[sep+1:]
            h1 = ''
        else:
            hdr = line
            line = ''
        if '=' in hdr:
            e = hdr.index('=')
            name = hdr[0:e]
            value = hdr[e+1:]
        else:
            name = hdr
            value = True
        d[name] = value
    return d

def compare_indent(l1,l2):
    len1 = 0
    while l1[len1] == ' ':
        len1 += 1
    len2 = 0
    while l2[len2] == ' ':
        len2 += 1
    return len2 - len1

# aaa:
#   We read a line
# bbb:
#   we create a hash
#   populate it with the entries we inherited
#   fill it with the entries for our current line
#   look at the indentation on the next line
#   If it's deeper or the same
#   If it's deeper
#     recurse, passing the hash
#     goto bbb
#   else
#     Create an object using the hash
#   If it's the same
#     goto aaa
#   return

def parse_file(file, doit, inherited):
#    print 'inherited', inherited
    while True:
        line = nextline(file)
        if line == '':
            break
#        print 'before_add', inherited
        us = add_entries(dict(inherited), line)
#        print 'inherited', inherited, 'us',us
        hadsub = False
        while True:
            peek = peekline(file)
#            print "comparing","'"+line+"'","'"+peek+"'"
            i = compare_indent(line, peek)
            if i > 0:
#                print 'recurse',us
                parse_file(file, doit, dict(us))
                hadsub = True
                continue
            if i == 0:
                if not hadsub:
                    doit(dict(us))
                break
            if i < 0:
                if not hadsub:
                    doit(dict(us))
                return

######## Date functions

month_names = ('Hammer', 'Alturiak', 'Ches', 'Tarsakh', 'Mirtul', 'Kythorn',
 'Flamerule', 'Eleasias', 'Eleint', 'Marpenoth', 'Uktar', 'Nightal')

festival_names = ('Midwinter', 'Greengrass', 'Midsummer', 'Higharvestide', 'Moon')

month_offset = { 'Hammer':0, 'Midwinter Festival':30, 'Alturiak':31, 'Ches':61,
 'Tarsakh':91, 'Greengrass Festival':121, 'Mirtul':122, 'Kythorn':152,
 'Flamerule':182, 'Midsummer Festival':212, 'Eleasias':213, 'Eleint':243,
 'Higharvestide Festival':273, 'Marpenoth':274, 'Uktar':304, 'Moon Festival':334,
 'Nightal':335}

def str_to_date(date):
    """ turn a human readable date (day month year) into a date_id"""
# 365 * (year-1368) + month_offset[month] + day

    if date == None:
        return None
    if date[0] == '(' and date[-1] ==')' and date.count(',') == 2:
        c1 = date.index(',')
        c2 = date[c1+1:].index(',')
        year = date[1:c1]
        month = date[c1+1:c1+c2+1]
        day = date[c1+c2+2:-1]
    else:
        c1 = date.index(' ')
        c2 = date[c1+1:].index(' ')
        if date[:c1] in festival_names and date[c1:c1+c2+2] == " Festival ":
            month = date[:c1+c2+1]
            day = 1
            year = date[c1+c2+2:]
        elif date[c1+1:c1+c2+1] in month_names:
            day = date[:c1]
            month = date[c1+1:c1+c2+1]
            year = date[c1+c2+2:]
        elif date[:c1] in month_names:
            month = date[:c1]
            day = date[c1+1:c1+c2+1]
            year = date[c1+c2+2:]
        else:
            raise NameError("Unknown date "+date)
    ret = 1000 + 365*(int(year)-1368)+month_offset[month]+int(day)-1
    return ret

#day_names = {
# 1:'First', 2:'Second', 3:'Third', 4:'Fourth', 5:'Fifth', 6:'Sixth',
# 7:'Seventh', 8:'Eighth', 9:'Ninth', 10:'Tenth', 11:'Eleventh', 12:'Twelth',
#13:'Thirteenth', 14:'Fourteenth', 15:'Fifteenth', 16:'Sixteenth', 17:'Seventeenth',
#18:'Eighteenth', 19:'Ninteenth', 20:'Twentieth', 21:'Twenty-First', 22:'Twenty-second',
#23:'Twenty-third', 24:'Twenty-fourth', 25:'Twenty-fifth', 26:'Twenty-sixth',
#27:'Twenty-seventh', 28:'Twenty-eighth', 29:'Twenty-ninth', 30:'Thirtyith'}

off_monthset = ((0,29, 'Hammer'), (30, 30, 'Midwinter Festival'),
 (31, 60, 'Alturiak'), (61, 90, 'Ches'), (91, 120, 'Tarsakh'),
 (121, 121, 'Greengrass Festival'), (122, 151, 'Mirtul'), (152, 181, 'Kythorn'),
 (182, 211, 'Flamerule'), (212, 212, 'Midsummer Festival'), (213, 242, 'Eleasias'),
 (243, 272, 'Eleint'), (273, 273, 'Higharvestide Festival'), (274, 303, 'Marpenoth'),
 (304, 333, 'Uktar'), (334, 334, 'Moon Festival'), (335, 364, 'Nightal'))

def date_to_str(date):
    """return a human-readable form of a date-id"""

    if date == None or date < 1000:
        return None
    date -= 1000
    year = 1368 + int(date/365)
    mo = date % 365
    for i in off_monthset:
        if mo >= i[0] and mo <= i[1]:
            month = i[2]
            if i[0] == i[1]:
                return month + ' ' + str(year)
            day = 1 + mo - i[0]
            return str(day)+' '+month+' '+str(year)
    raise NameError("Couldn't find date '" + str(date))+"'"

######## Copper and Gold piece functions

def cp_to_gp(cp) :
    """ return the gp portion of a raw cp value"""

    return cp/200


def cp_to_cp_only(cp) :
    """ return the cp portion of a raw cp value"""

    return cp % 200


def gp_cp_to_cp(gp, cp) :
    """ turn gp and cp values into a raw cp value"""

    return int(float(gp) * 200 + float(cp))


def str_gp_cp(gp, cp) :
    """ pretty-print a gp and cp value for human consumption"""

    if gp > 0 and cp > 0 :
        return str(gp)+"gp, "+str(cp)+"cp"
    elif gp > 0 :
        return str(gp)+"gp"
    elif cp > 0 :
        return str(cp)+"cp"
    else :
        return "nothing"


def str_cp(cp) :
    """ pretty-print a raw cp value"""

    return str_gp_cp(cp_to_gp(cp), cp_to_cp_only(cp))


def str_cp_to_fgp(cp) :
    """print copper pieces as fractional gold pieces"""

    return str(float(cp)/200.0)


def divide_cp(top, bottom) :
    """Perform an integer division, rounding up randomly"""

    whole = int(top/bottom)
    fract = (float(top)/float(bottom)) - whole
    if fract > random.random() :
#        print top,"/",bottom,"=",whole,"fraction",fract,"rounded up"
        whole += 1
    return whole


######## Journal entries

def journal(date, by, to, amount, description, part_of = None):
    """add an entry to the transaction journal, returning an id that may be used for subsequent calls"""

    cur.execute (
 "insert into fr_journal ( made_on, made_by, made_to, amount_cp, description, part_of ) "
 " values ( %(date)s, %(by)s, %(to)s, %(cp)s, %(text)s, %(part_of)s )",
 { 'date' : date, 'by' : by, 'to' : to, 'cp' : amount, 'text' :
 description + ".", 'part_of' : part_of } )
    return cur.lastrowid

def get_journal_dates():
    """return a list of dates (in text form) of entries in the journal"""
    cur.execute("select distinct made_on from fr_journal order by made_on")
    resp = cur.fetchall()
    if resp == None or len(resp)==0:
        return resp
    ret=[]
    for i in resp:
        ret.append(date_to_str(i[0]))
    return ret
    
def get_journal(d_fm = None, d_to = None, character = None, primary = False):
    """return a list of dicts of entries in the journal"""

    string = ""
    if d_fm is not None and d_to is not None:
        string += " where made_on >= %(d_fm)s and made_on <= %(d_to)s "
    elif d_fm is not None:
        string += " where made_on >= %(d_fm)s "
    elif d_to is not None:
        string += " where made_on <= %(d_to)s "
    if primary:
        if string != '':
            s1 = ' and '
        else:
            s1 = ' where '
        string += s1 + 'part_of is NULL'
    if character is not None:
        if string != '':
            s1 = " and ( "
            s2 = ' ) '
        else:
            s1 = " where "
            s2 = ' '
        string += s1+" made_by = %(character)s or made_to = %(character)s "+s2

    cur.execute("select "
" journal_id, part_of, ourtime, made_on, made_by, made_to, amount_cp, description"
" from fr_journal " + string + " order by made_on, journal_id",
{'d_fm':d_fm, 'd_to':d_to, 'character':character})
    resp = cur.fetchall()
    if resp == None or len(resp) == 0:
        return resp
    ret=[]
    for i in resp:
        t = {}
        t['journal_id'] = i[0]
        t['part_of'] = i[1]
        t['ourtime'] = i[2]
        t['made_on'] = date_to_str(i[3])
        t['made_by'] = i[4]
        t['made_to'] = i[5]
        t['amount_cp'] = i[6]
        t['description'] = i[7]
        ret.append(t)
    return ret

########## Characters

def in_or_none(k,d):
    return d[k] if k in d else None

def ins_if_not(d,l):
    for k in l:
        if not k in d:
            d[k] = None

def insert_char(d):
    """ insert a character into the database"""

    ins_if_not(d,('fullname', 'player', 'gender', 'race', 'class', 'alignment',
 'picture', 'equipment', 'characteristics', 'notes', 'association', 'dm_notes',
 'large_picture'))
    if 'cp' not in d:
        d['cp'] = 0
    if 'gold' in d:
        d['cp'] = gp_cp_to_cp(d['gold'],d['cp'])
    cur.execute(
 "insert into fr_character ( char_name, char_status, "
 " char_alignment, "
 " char_association, "
 " char_acteristics, "
 " char_class, "
 " char_dm_notes, "
 " char_equipment, "
 " char_fullname, "
 " char_gender, "
 " char_notes, "
 " char_player, "
 " char_race, "
 " char_cash, "
 " char_picture_url, "
 " char_large_picture_url ) "
 " values ( %(name)s, %(status)s, "
 " %(alignment)s, "
 " %(association)s, "
 " %(characteristics)s, "
 " %(class)s, "
 " %(dm_notes)s, "
 " %(equipment)s, "
 " %(fullname)s, "
 " %(gender)s, "
 " %(notes)s, "
 " %(player)s, "
 " %(race)s, "
 " %(cp)s, "
 " %(picture)s, "
 " %(large_picture)s )", d )

def get_char_id(char_name) :
    """ given a char_name, return its corresponding char_id"""

    cur.execute("select char_id from fr_character where char_name = %(char_name)s", {'char_name': char_name})
    resp = cur.fetchall()
    if len(resp) != 1 or len(resp[0]) != 1 :
        raise NameError("Couldn't find char_name '" + char_name+"'")
    return resp[0][0]


def get_char_cash(char_id) :
    """given a char_id, return their cash in cps"""

    cur.execute("select char_cash from fr_character where char_id = %(char_id)s",{'char_id':char_id})
    resp = cur.fetchall()
    if len(resp) != 1 or len(resp[0]) != 1 :
        raise NameError("Couldn't find char_id '" + str(char_id)+"'")
    return resp[0][0]


def chars_move_cash(i):
    """move cash from one character to another, journaling it"""

    if not 'from_name' in i:
        i['from_name'] = get_char_name(i['from_id'])
    if not 'to_name' in i:
        i['to_name'] = get_char_name(i['to_id'])
    if 'item_id' in i and i['item_id'] and not 'item_name' in i:
        i['item_name'] = get_item_name(i['item_id'])
    if not 'part_of' in i:
        i['part_of'] = None

    if i['to_id'] >= party:
       cur.execute("update fr_character set char_cash = "
 " char_cash + %(cp)s where char_id = %(to_id)s",
 { 'cp' : i['amount'], 'to_id' : i['to_id'] } )
    if i['from_id'] >= party:
        cur.execute("update fr_character set char_cash = "
 " char_cash - %(cp)s where char_id = %(from_id)s",
 { 'cp' : i['amount'], 'from_id' : i['from_id'] } )
    text = i['from_name'] + ' gave ' + str_cp(i['amount']) + ' to ' + i['to_name']
    if 'item_name' in i and i['item_name'] is not None:
        t_for = " for " + i['item_name']
    if 'note' in i and i['note'] is not None:
        text += i['note']
    journal(i['date'], i['from_id'], i['to_id'], i['amount'], text, i['part_of'])

def get_char_name(char_id) :
    """ given a char_id, return its corresponding char_name """

    cur.execute("select char_name from fr_character where char_id = %(char_id)s", {'char_id':char_id })
    resp = cur.fetchall()
    if len(resp) != 1 or len(resp[0]) != 1 :
        raise NameError("Couldn't find char_id '"+str(char_id)+"'")
    return resp[0][0]


def get_characters() :
    """return a list of [id name] entries for all the characters in the database"""

    cur.execute("select char_id, char_name from fr_character "
 " where char_id >= %(first_real_char)s and char_association = 'AFAL' and char_status = 'active' "
 " order by char_name",
 {'first_real_char':first_real_char})
    resp = cur.fetchall()
    if len(resp) < 1 or len(resp[0]) != 2 :
        raise NameError("Couldn't find any characters")
    return resp


def get_char_data(char_id) :
    """ given a char_id, return its  """

    cur.execute("select char_name, char_fullname, char_player, char_gender, "
 " char_race, char_class, char_alignment, char_picture_url, char_equipment, "
 " char_acteristics, char_notes, char_association, char_status, char_cash, "
 " char_large_picture_url "
 " from fr_character where char_id = %(char_id)s", {'char_id':char_id })
    resp = cur.fetchall()
    if len(resp) != 1:
        raise NameError("Couldn't find char_id '"+str(char_id)+"'")
    resp = resp[0]
    ret = {}
    ret['name'] = resp[0]
    ret['fullname'] = resp[1]
    ret['player'] = resp[2]
    ret['gender'] = resp[3]
    ret['race'] = resp[4]
    ret['class'] = resp[5]
    ret['alignment'] = resp[6]
    ret['picture_url'] = resp[7]
    ret['equipment'] = resp[8]
    ret['characteristics'] = resp[9]
    ret['notes'] = resp[10]
    ret['association'] = resp[11]
    ret['status'] = resp[12]
    ret['cash'] = resp[13]
    ret['large_picture_url'] = resp[14]
    return ret

########## Parties

def get_party_id(party_name) :
    """given a party_name, return the corresponding party_id"""

    cur.execute("select party_id from fr_party where party_name = %(party_name)s",
 { 'party_name': party_name })
    resp = cur.fetchall()
    if len(resp) != 1 or len(resp[0]) != 1 :
        raise NameError("Couldn't find party_name '" + party_name+"'")
    return resp[0][0]


def get_party_name(party_id) :
    """given a party_id, return the corresponding party_name"""

    cur.execute("select party_name from fr_party where party_id = %(party_id)s",
 { 'party_id': party_id })
    resp = cur.fetchall()
    if len(resp) != 1 or len(resp[0]) != 1 :
        raise NameError("Couldn't find party_id '" + party_id+"'")
    return resp[0][0]


def get_party_members(party_id) :
    """Given a party, return a list [id, share] entries for its members"""

    cur.execute("select char_id, share from fr_char_party where party_id = %(p)s",
 { 'p' : party_id } )
    resp = cur.fetchall()
    if len(resp) < 1 or len(resp[0]) < 1 :
        raise NameError("Couldn't find characters for party '"+str(party_id)+"'")
    return resp


def get_char_parties(char_id) :
    """Return a list of [party_id, share] that the character is in"""

    cur.execute("select fr_char_party.party_id, fr_char_party.share from fr_char_party natural join fr_party where fr_char_party.char_id = %(char_id)s order by fr_party.party_date",
 {'char_id':char_id})
    resp = cur.fetchall()
#    if len(resp) < 1 or len(resp[0]) < 1 :
#        raise NameError("Couldn't find parties for char_id '"+str(char_id)+"'")
    return resp

def get_parties():
    """Return a list of [id, name] entries for all the parties in the database"""

    cur.execute("select party_id, party_name from fr_party order by party_date")
    resp = cur.fetchall()
    if len(resp) < 1 or len(resp[0]) < 1 :
        raise NameError("Couldn't find any parties")
    return resp


def insert_party(party_name,party_date):
    """insert a party into the database"""

    cur.execute(
 "insert into fr_party (party_name, party_date) values (%(name)s, %(date)s)",
 {'name':party_name, 'date':party_date})
    return cur.lastrowid


def insert_char_party(char_id, party_id, share=1.0) :
    """insert a char_party into the database"""

    cur.execute(
 "insert into fr_char_party ( char_id, party_id, share ) values ( %(char_id)s, %(party_id)s, %(share)s )",
 { 'char_id' : char_id, 'party_id' : party_id, 'share' : share })


########## Items

def get_item_name(id) :
    """ given an item_id, return its corresponding item_name"""

    cur.execute("select item_name from fr_item where item_id = %(id)s", {'id':id })
    resp = cur.fetchall()
    if len(resp) != 1 or len(resp[0]) != 1 :
        raise NameError("Couldn't find item_name for '"+str(id)+"'")
    return resp[0][0]


def get_item_id(item_name) :
    """ given an item name, return its corresponding item_id

The database now has a unque constraint on item names, so this can't return
multiple items."""
    cur.execute("select item_id from fr_item where item_name = %(name)s",
 {'name': item_name })
    resp = cur.fetchall()
    if len(resp) != 1 or len(resp[0]) != 1 :
        raise NameError("Couldn't find a unique item_id for '" + item_name+"'")
    return resp[0][0]


def insert_item(d):
    """insert an item into the database"""

    if not 'owner_id' in d:
        d['owner_id'] = None
    if not 'sale_date' in d:
        d['sale_date'] = None
    if not 'value_cp' in d:
        d['value_cp'] = None
    if not 'note' in d:
        d['note'] = None

    cur.execute(
 " insert into fr_item(item_name, owned_by, sale_date, value, note, acquired_by)"\
 " values(%(name)s, %(owner_id)s, %(sale_date)s, %(value_cp)s, %(note)s,"\
 "  %(party_id)s)", d)
    return cur.lastrowid


def get_item_owner(item_id) :
    """Get the owner of an item"""

    cur.execute ( "select owned_by, sale_date from fr_item where item_id = %(item_id)s",
 { 'item_id' : item_id } )
    resp = cur.fetchall()
    if len(resp) != 1 or len(resp[0]) != 2 :
        raise NameError("Couldn't find seller for item id '" + str(item_id)+"'")
    if resp[0][1] is None:
        return party
    return resp[0][0]


def get_item_acquired_by(item_id) :
    """get the party that acquired an item"""

    cur.execute("select acquired_by from fr_item where item_id = %(item_id)s",
 {'item_id':item_id})
    resp = cur.fetchall()
    if len(resp) != 1 or len(resp[0]) != 1 :
        raise NameError("Couldn't find acquirer for item id '" + str(item_id)+"'")
    return resp[0][0]


def change_item_owner(item_id, char_id, value, date):
    """Change the ownership, transfer date, and value of an item"""

    cur.execute("update fr_item set owned_by = %(char_id)s, value = %(value)s, "
 " sale_date =  %(date)s where item_id = %(item_id)s",
 {'char_id':char_id, 'value':value, 'date':date, 'item_id':item_id})


def get_items_owned_by(char_id):
    cur.execute("select item_name, note, value, sale_date from fr_item where owned_by = %(char_id)s order by item_name", {'char_id':char_id})
    resp = cur.fetchall()
    if resp == None or len(resp) == 0:
        return resp
    ret=[]
    for i in resp:
        t = {}
        t['item_name'] = i[0]
        t['note'] = i[1]
        t['value'] = i[2]
        t['sale_date'] = date_to_str(i[3])
        ret.append(t)
    return ret


def get_items_acquired_by(party_id) :
    cur.execute("select item_name, note, value, owned_by, sale_date from fr_item where acquired_by = %(party_id)s order by item_name", {'party_id':party_id})
    resp = cur.fetchall()
    if resp is None or len(resp) == 0:
        return resp
    ret = []
    for i in resp:
        t = {}
        t['item_name'] = i[0]
        t['note'] = i[1]
        t['value'] = i[2]
        t['owned_by'] = i[3]
        t['sale_date'] = date_to_str(i[4])
        ret.append(t)
    return ret


def get_party_items() :
   cur.execute("select item_name, note, value, owned_by from fr_item where sale_date is null order by item_name")
   resp = cur.fetchall()
   return resp

def get_unresolved_items():
    cur.execute("select acquired_by, item_name, note from fr_item where owned_by is NULL")
    resp = cur.fetchall()
    ret = []
    for i in resp:
        t = {}
        t['acquired_by'] = get_party_name(i[0])
        t['item_name'] = i[1]
        t['note'] = i[2]
        ret.append(t)
    return ret

######## Debts

def get_char_receivable(char_id) :
    cur.execute (
 "select debt_id, from_char, repay_order, owed_cp, share, owed_on, item_id, initial_cp "
 " from fr_debt where to_char = %(id)s order by from_char, repay_order",
 { 'id' : char_id } )
    resp = cur.fetchall()
    if resp is None or len(resp) == 0:
        return resp
    ret = []
    for i in resp:
        t = {}
        t['debt_id'] = i[0]
        t['to_id'] = char_id
        t['from_id'] = i[1]
        t['order'] = i[2]
        t['amount'] = i[3]
        t['share'] = i[4]
        t['item_id'] = i[6]
        t['contracted_on'] = date_to_str(i[5])
        t['initial_cp'] = i[7]
        ret.append(t)
    return ret


def get_char_payable(char_id) :
    cur.execute ( "select "
 " debt_id, to_char, repay_order, owed_cp, share, owed_on, item_id, initial_cp "
 " from fr_debt where from_char = %(id)s order by to_char, repay_order",
 { 'id' : char_id } )
    resp = cur.fetchall()
    if resp is None or len(resp) == 0:
        return resp
    ret = []
    for i in resp:
        t = {}
        t['debt_id'] = i[0]
        t['from_id'] = char_id
        t['to_id'] = i[1]
        t['order'] = i[2]
        t['amount'] = i[3]
        t['share'] = i[4]
        t['contracted_on'] = date_to_str(i[5])
        t['item_id'] = i[6]
        t['initial_cp'] = i[7]
        ret.append(t)
    return ret


def get_char_rec_xferable(char_id) :
    cur.execute (
 "select tob.debt_id, tob.from_char, tob.repay_order, tob.owed_cp, tob.share, tob.item_id "
 "from fr_debt as tob where tob.to_char = %(char_id)s and tob.repay_order = "
 " ( select min(froma.repay_order) from debt as froma where froma.from_char = tob.from_char ) order by from_char",
 { 'char_id' : char_id })
    resp = cur.fetchall()
    if resp is None or len(resp) == 0:
        return resp
    ret = []
    for i in resp:
        t = {}
        t['debt_id'] = i[0]
        t['from_id'] = i[1]
        t['to_id'] = char_id
        t['order'] = i[2]
        t['amount'] = i[3]
        t['share'] = i[4]
        t['item_id'] = i[5]
        ret.append(t)
    return ret


def get_char_pay_xferable(char_id) :
    cur.execute(
 "select fromb.debt_id, fromb.to_char, fromb.repay_order, fromb.owed_cp, fromb.share, fromb.item_id "
 "from fr_debt as fromb where fromb.from_char = %(char_id)s and fromb.repay_order = ( select min(toc.repay_order) from fr_debt as toc where toc.from_char = %(char_id)s) order by to_char",
 {'char_id':char_id})
    resp = cur.fetchall()
    if resp is None or len(resp) == 0:
        return resp
    ret = []
    for i in resp:
        t = {}
        t['debt_id'] = i[0]
        t['from_id'] = char_id
        t['to_id'] = i[1]
        t['order'] = i[2]
        t['amount'] = i[3]
        t['share'] = i[4]
        t['item_id'] = i[5]
        ret.append(t)
    return ret

def bump_debt_repay_order(debt_id) :
    """increase the repay_order of the specified debt"""
    cur.execute ( "update fr_debt set repay_order = repay_order + 1 where debt_id = %(debt_id)s", {'debt_id':debt_id})


def get_char_selfdebt(char_id) :
    """returns a list of [debt_id, owed] for debts the specified character has to themself"""
    cur.execute ( "select debt_id, owed_cp from fr_debt where to_char = %(char_id)s and from_char = %(char_id)s", { 'char_id' : char_id } )
    return cur.fetchall()


def delete_debt(d, verb):
    """Deletes the specified debt and journal it"""

    if not 'from_name' in d:
        d['from_name'] = get_char_name(d['from_id'])
    if not 'to_name' in d:
        d['to_name'] = get_char_name(d['to_id'])
    if 'item_id' in d and d['item_id'] is not None and not 'item_name' in d:
        d['item_name'] = get_item_name(d['item_id'])
    if not 'part_of' in d:
        d['part_of'] = None

    cur.execute ( "delete from fr_debt where debt_id = %(debt_id)s", d )
    text = d['from_name'] + verb + 'a ' + str_cp(d['amount']) + ' debt'
    if d['from_id'] != d['to_id']:
        text += ' to '+ d['to_name']
    if 'item_name' in d:
        text += ' for ' + d['item_name']
    if 'note' in d and d['note'] is not None:
        text += d['note']
    journal(d['date'], d['from_id'], d['to_id'], d['amount'], text, d['part_of'] )

def debt_lower_owed(d, cp, verb):
    """Lower the amount owed on the specified debt and journal it"""

    if not 'from_name' in d:
        d['from_name'] = get_char_name(d['from_id'])
    if not 'to_name' in d:
        d['to_name'] = get_char_name(d['to_id'])
    if 'item_id' in d and d['item_id'] is not None and not 'item_name' in d:
        d['item_name'] = get_item_name(d['item_id'])
    if not 'part_of' in d:
        d['part_of'] = None

    new_amount = d['amount'] - cp
    cur.execute("update fr_debt set owed_cp = %(new_amount)s "
 " where debt_id = %(debt_id)s", {'new_amount':new_amount, 'debt_id':d['debt_id']})
    text = d['from_name'] + verb + str_cp(cp) + ' of a ' + str_cp(d['amount']) + ' debt to ' + d['to_name'] + ', leaving ' + str_cp(new_amount)
    if 'item_name' in d:
        text += ' for ' + d['item_name']
    if 'note' in d and d['note'] is not None:
        text += d['note']
    journal(d['date'], d['from_id'], d['to_id'], cp, text, d['part_of'])

def insert_debt(d):
    """insert a debt into the database and journal it"""

    if not 'repay_order' in d:
        d['repay_order'] = 0
    if not 'share' in d:
        d['share'] = 1.0
    if not 'item_id' in d:
        d['item_id'] = None

    if not 'from_name' in d:
        d['from_name'] = get_char_name(d['from_id'])
    if not 'to_name' in d:
        d['to_name'] = get_char_name(d['to_id'])
    if 'item_id' in d and d['item_id'] and not 'item_name' in d:
        d['item_name'] = get_item_name(d['item_id'])
    if not 'part_of' in d:
        d['part_of'] = None

    cur.execute("insert into fr_debt "
 " (from_char, to_char, repay_order, share, item_id, initial_cp, owed_cp, owed_on) "
 " values ( %(from_id)s, %(to_id)s, %(repay_order)s, %(share)s, %(item_id)s, "
 " %(amount)s, %(amount)s, %(date)s)", d)

    text =  d['from_name'] + " owed " + str_cp(d['amount']) + " to " + d['to_name']
    if d['repay_order'] != 0:
        text += " repay order " + str(d['repay_order'])
    if d['share'] != 1.0:
        text += " for " + str(d['share']) + " share"
    if 'item_name' in d and d['item_name'] is not None:
        text += " for " + d['item_name']
    if 'note' in d and d['note'] is not None:
        text += d['note']
    journal(d['date'], d['from_id'], d['to_id'], d['amount'], text, d['part_of'])

######## End
