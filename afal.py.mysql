#!/usr/bin/python
import sys
import mysql.connector
from mysql.connector import errorcode
import random
import re

############################## begin startup code here


config = {
	'database':'afal_devel', 'user':'afal'
, 'password':'BuffyStewart'
}
conn = mysql.connector.connect(**config)
conn.get_warnings = True
cur = conn.cursor()

auction = 'Auction'
sell = 'Sell'
destroyed = 'destroyed'
outside = 'outside the party'
party = 'party'
special = (auction, sell, destroyed, outside)

######## Cleanup and misc code

def commit():
    conn.commit()


def fini():
    """finish things up and close the database"""
    conn.commit()
    cur.close()
    conn.close()


def _ins_if_not(d, l):
    for k in l:
        if k not in d:
            d[k] = None


# if may is None, don't check for extra keys at all
def _check_dict(d, must = None, may = None):
    """ dict must contain every element in 'must', and may contain elements in 'may'"""

    if may is not None:
        for i in d:
            if i not in must and i not in may:
                print "\nUnexpected key '" + i + "' found in dict", d, "only expected must=", must, "may=", may, "\n"
                raise NameError("Unexpected key " + i)

    for i in must:
	if not i in d:
            print "\nMissing key '" + i + "' in dict", d, "expected must=", must, "\n"
            raise NameError("Missing key " + i)


def _check_warnings():
    warnings = cur.fetchwarnings()
    if warnings:
        print "\nWarnings!:",warnings,"\n"

######## File IO and parsing

def _nextline(f):
    if _nextline.line:
        ret = _nextline.line
        _nextline.line = None
        return ret
    ret = ''
    while True:
        tmp = f.readline()
        if len(tmp) < 1:
            break
        if tmp[0] == '#':
            continue
        if tmp[-1] == '\n':
            tmp = tmp[:-1]
            if len(tmp) < 1:
                break
        if tmp[-1] != '\\':
            ret += tmp
            break
        ret += tmp[:-1]
    return ret


_nextline.line = None
_indent = ' ,'

def _peekline(file):
    line = _nextline(file)
    if _nextline.line:
        raise NameError("Line already pushed")
    _nextline.line = line
    if line == '':
        return '\n'
    return line

def _add_entries(d, line):
    while line[0] in _indent:
        line = line[1:]
    h1 = ''
    while len(line) > 0:
        if ';' in line:
            sep = line.index(';')
            if sep > 0 and line[sep-1] == '\\':
                h1 += line[0:sep-1] + ';'
                line = line[sep+1:]
                continue
            hdr = h1 + line[0:sep]
            line = line[sep+1:]
            h1 = ''
        else:
            hdr = h1+line
            line = ''
        if '=' in hdr:
            e = hdr.index('=')
            name = hdr[0:e]
            value = hdr[e+1:]
        else:
            name = hdr
            value = True
        if name in d:
            print d
            raise NameError("Key '"+name+"' is already in dict")
        d[name] = value
    return d

def _compare_indent(l1, l2):
    len1 = 0
    while l1[len1] in _indent:
        len1 += 1
    len2 = 0
    while l2[len2] in _indent:
        len2 += 1
    return len2 - len1

# aaa:
#   We read a line
# bbb:
#   we create a hash
#   populate it with the entries we inherited
#   fill it with the entries for our current line
#   look at the indentation on the next line
#   If it's deeper or the same
#   If it's deeper
#     recurse, passing the hash
#     goto bbb
#   else
#     Create an object using the hash
#   If it's the same
#     goto aaa
#   return

def parse_file(file, doit, inherited):
    while True:
        line = _nextline(file)
        if line == '':
            break
        us = _add_entries(dict(inherited), line)
        hadsub = False
        while True:
            peek = _peekline(file)
            i = _compare_indent(line, peek)
            if i > 0:
                parse_file(file, doit, dict(us))
                hadsub = True
                continue
            if i == 0:
                if not hadsub:
                    doit(dict(us))
                break
            if i < 0:
                if not hadsub:
                    doit(dict(us))
                return

######## Date functions

month_names = ('Hammer', 'Alturiak', 'Ches', 'Tarsakh', 'Mirtul', 'Kythorn',
 'Flamerule', 'Eleasias', 'Eleint', 'Marpenoth', 'Uktar', 'Nightal')

festival_names = ('Midwinter', 'Greengrass', 'Midsummer', 'Higharvestide', 'Moon')

month_offset = {'Hammer':0, 'Midwinter Festival':30, 'Alturiak':31, 'Ches':61,
 'Tarsakh':91, 'Greengrass Festival':121, 'Mirtul':122, 'Kythorn':152,
 'Flamerule':182, 'Midsummer Festival':212, 'Eleasias':213, 'Eleint':243,
 'Higharvestide Festival':273, 'Marpenoth':274, 'Uktar':304, 'Moon Festival':334,
 'Nightal':335}

def str_to_date(date):
    """ turn a human readable date (day month year) into a date_id"""
# 365 * (year-1368) + month_offset[month] + day

    if date is None or type(date) is int:
        return date
    if date[0] == '(' and date[-1] ==')' and date.count(',') == 2:
        c1 = date.index(',')
        c2 = date[c1+1:].index(',')
        year = date[1:c1]
        month = date[c1+1:c1+c2+1]
        day = date[c1+c2+2:-1]
    else:
        c1 = date.index(' ')
        c2 = date[c1+1:].index(' ')
        if date[:c1] in festival_names and date[c1:c1+c2+2] == " Festival ":
            month = date[:c1+c2+1]
            day = 1
            year = date[c1+c2+2:]
        elif date[c1+1:c1+c2+1] in month_names:
            day = date[:c1]
            month = date[c1+1:c1+c2+1]
            year = date[c1+c2+2:]
        elif date[:c1] in month_names:
            month = date[:c1]
            day = date[c1+1:c1+c2+1]
            year = date[c1+c2+2:]
        else:
            raise NameError("Unknown date "+date)
    ret = 1000 + 365 * (int(year) - 1368) + month_offset[month] + int(day) - 1
    return ret

#day_names = {
# 1:'First', 2:'Second', 3:'Third', 4:'Fourth', 5:'Fifth', 6:'Sixth',
# 7:'Seventh', 8:'Eighth', 9:'Ninth', 10:'Tenth', 11:'Eleventh', 12:'Twelth',
#13:'Thirteenth', 14:'Fourteenth', 15:'Fifteenth', 16:'Sixteenth', 17:'Seventeenth',
#18:'Eighteenth', 19:'Ninteenth', 20:'Twentieth', 21:'Twenty-First', 22:'Twenty-second',
#23:'Twenty-third', 24:'Twenty-fourth', 25:'Twenty-fifth', 26:'Twenty-sixth',
#27:'Twenty-seventh', 28:'Twenty-eighth', 29:'Twenty-ninth', 30:'Thirtyith'}

off_monthset = ((0, 29, 'Hammer'), (30, 30, 'Midwinter Festival'),
 (31, 60, 'Alturiak'), (61, 90, 'Ches'), (91, 120, 'Tarsakh'),
 (121, 121, 'Greengrass Festival'), (122, 151, 'Mirtul'), (152, 181, 'Kythorn'),
 (182, 211, 'Flamerule'), (212, 212, 'Midsummer Festival'), (213, 242, 'Eleasias'),
 (243, 272, 'Eleint'), (273, 273, 'Higharvestide Festival'), (274, 303, 'Marpenoth'),
 (304, 333, 'Uktar'), (334, 334, 'Moon Festival'), (335, 364, 'Nightal'))

def date_to_str(date):
    """return a human-readable form of a date-id"""

    try:
        date = int(date)
    except:
        return date
    if date < 1000:
        raise NameError("Invalid date " + str(date))
    date -= 1000
    year = 1368 + int(date/365)
    mo = date % 365
    for i in off_monthset:
        if mo >= i[0] and mo <= i[1]:
            month = i[2]
            if i[0] == i[1]:
                return month + ' ' + str(year)
            day = 1 + mo - i[0]
            return month+' '+str(day)+' '+str(year)
    raise NameError("Couldn't find date '" + str(date))+"'"

def party_to_date(d):
    return str_to_date(re.sub(r'^([^-]*-)?([^-]+)-(Festival|[0-9]+)[A-Za-z]?-([^-]+)$', r'\2 \3 \4', d))

######## Copper and Gold piece functions


def _or_zero(x):
    return int(x) if x is not None and len(x) > 0 else 0

def str_to_cp(s):
    if s is None:
        return None
    m = re.match(r'^((\d+)\s*hm,?\s*)?((\d+)\s*gond bells?,?\s*)?((\d+)\s*pp,?\s*)?((\d+)\s*toals?,?\s*)?((\d+)\s*gp,?\s*)?((\d+)\s*ep,?\s*)?((\d+)\s*sp,?\s*)?((\d+)\s*cp)?$', s, re.IGNORECASE)
    if m:
        hm = _or_zero(m.group(2))
	gb = _or_zero(m.group(4))
	pp = _or_zero(m.group(6))
	to = _or_zero(m.group(8))
	gp = _or_zero(m.group(10))
	ep = _or_zero(m.group(12))
	sp = _or_zero(m.group(14))
	cp = _or_zero(m.group(16))
	return int(hm * 10000 + gb * 2000 + pp * 1000 + to * 400 + gp * 200 \
 + ep * 100 + sp * 10 + cp)
    else:
        return int(float(s) * 200)


def cp_to_str(cp):
    """ pretty-print a raw cp value"""

    if cp is None:
        return ''
    if cp == 0:
        return "nothing"
    if cp < 0:
        return "NEGATIVE MONEY " + str(int(-cp/200)) + "gp, " + str(-cp%200) + "cp"
    gp = int(cp/200)
    cp = cp % 200
    if gp > 0 and cp > 0:
        return str(gp) + "gp, " + str(cp) + "cp"
    elif gp > 0:
        return str(gp) + "gp"
    else:
        return str(cp) + "cp"


def divide_cp(top, bottom):
    """Perform an integer division, rounding up randomly"""

    whole = int(top/bottom)
    fract = (float(top)/float(bottom)) - whole
    if fract > random.random():
        whole += 1
    return whole


######## Shares


def share_to_str(share):
    if share == int(share):
        return str(int(share))
    return str(share)


######## Journal entries

def journal(date, by, to, amount_cp, text, part_of = None):
    """add an entry to the transaction journal, returning an id that may be used for subsequent calls"""

    if date is None or by is None or text is None:
        raise NameError("Missing required field in journal")
    date = str_to_date(date)
    cur.execute (
 "insert into fr_journal ( date, made_by, made_to, amount_cp, description, part_of ) "
 " values ( %(date)s, %(by)s, %(to)s, %(cp)s, %(text)s, %(part_of)s )",
 {'date':date, 'by':by, 'to':to, 'cp':amount_cp,
 'text':text + ".", 'part_of':part_of})
    _check_warnings()
    return cur.lastrowid

def get_journal_dates():
    """return a list of dates (in text form) of entries in the journal"""
    cur.execute("select distinct date from fr_journal order by date")
    resp = cur.fetchall()
    _check_warnings()
    if resp == None or len(resp)==0:
        return resp
    ret=[]
    for i in resp:
        ret.append(date_to_str(i[0]))
    return ret
    
def get_journal(d_fm = None, d_to = None, character = None, primary = False):
    """return a list of dicts of entries in the journal"""

    string = ""
    if d_fm == 'All':
        d_fm = None
    else:
        d_fm = str_to_date(d_fm)
    if d_to == 'All':
        d_to = None
    else:
        d_to = str_to_date(d_to)
    if character == 'All':
        character = None
    if d_fm and d_to:
        string += " where date >= %(d_fm)s and date <= %(d_to)s "
    elif d_fm:
        string += " where date >= %(d_fm)s "
    elif d_to:
        string += " where date <= %(d_to)s "
    if primary:
        if string != '':
            s1 = ' and '
        else:
            s1 = ' where '
        string += s1 + 'part_of is NULL'
    if character is not None:
        if string != '':
            s1 = " and ( "
            s2 = ' ) '
        else:
            s1 = " where "
            s2 = ' '
        string += s1+" made_by = %(character)s or made_to = %(character)s "+s2

    cur.execute("select "
" journal_id, part_of, ourtime, date, made_by, made_to, amount_cp, description"
" from fr_journal " + string + " order by date, journal_id",
{'d_fm':d_fm, 'd_to':d_to, 'character':character})
    resp = cur.fetchall()
    _check_warnings()
    if resp == None or len(resp) == 0:
        return resp
    ret=[]
    for i in resp:
        t = {}
        t['journal_id'] = i[0]
        t['part_of'] = i[1]
        t['ourtime'] = i[2]
        t['date'] = date_to_str(i[3])
        t['made_by'] = i[4]
        t['made_to'] = i[5]
        t['amount_cp'] = i[6]
        t['description'] = i[7].format(by=i[4], to=i[5], amount=cp_to_str(i[6]))
        ret.append(t)
    return ret

########## Characters


def insert_character(d):
    """ insert a character into the database"""

    _check_dict(d, must=('name', 'status', 'association'), may=(
 'alignment', 'characteristics', 'class', 'hidden_note', 'equipment',
 'fullname', 'gender', 'note', 'player', 'race', 'cash', 'picture',
 'large_picture'))
    _ins_if_not(d, ('alignment', 'association', 'characteristics', 'class',
 'equipment', 'fullname', 'hidden_note', 'large_picture', 'note', 'picture',
'player', 'race'))
    if 'gender' not in d:
        d['gender'] = 'Unknown Gender'
    if 'cash' in d:
        d['cash_cp'] = str_to_cp(d['cash'])
    else:
        d['cash_cp'] = 0
    cur.execute(
 "insert into fr_character ( "
 " char_name, status, alignment, association, "
 " char_acteristics, class, hidden_note, equipment, "
 " fullname, gender, note, player, "
 " race, cash_cp, picture_url, large_picture_url ) "
 " values ( "
 " %(name)s, %(status)s, %(alignment)s, %(association)s, "
 " %(characteristics)s, %(class)s, %(hidden_note)s, %(equipment)s, "
 " %(fullname)s, %(gender)s, %(note)s, %(player)s, "
 " %(race)s, %(cash_cp)s, %(picture)s, %(large_picture)s )", d )
    _check_warnings()



def chars_move_cash(i):
    """move cash from one character to another, journaling it"""

    _check_dict(i, must=('date', 'by', 'to', 'amount_cp'), may=( 'item', 'for', 'note', 'part_of'))
    by = i['by']
    to = i['to']
    amount_cp = i['amount_cp']
    if to not in special:
        cur.execute("update fr_character set cash_cp = "
 " cash_cp + %(cp)s where char_name = %(to)s",
 {'cp': amount_cp, 'to': to})
        _check_warnings()
    if by not in special:
        cur.execute("update fr_character set cash_cp = "
 " cash_cp - %(cp)s where char_name = %(by)s",
 {'cp': amount_cp, 'by': by})
        _check_warnings()
    text = '{by} gave {amount} to {to}'
    if i.get('item'):
        t_for = " for " + i['item']
    if i.get('for'):
        t_for = " for " + i['for']
    if i.get('note'):
      text += ' ' + i.get('note','')
    journal(str_to_date(i['date']), by, to, amount_cp, text, i.get('part_of'))


def get_characters(kind, match = None):
    """return a list of name entries for characters in the database"""

    clause = ''
    if kind == 'All':
        clause = 'status != "dummy"'
    elif kind == 'Current':
        clause = 'status = "active" and association = "AFAL"'
    elif kind == 'Former':
        clause = 'status = "inactive" and association = "AFAL"'
    elif kind == 'Dead':
        clause = 'status = "dead" and association = "AFAL"'
    elif kind == 'ActiveNPCs':
        clause = 'status = "active" and association != "AFAL"'
    elif kind == 'InactiveNPCs':
        clause = 'status = "inactive" and association != "AFAL"'
    elif kind == 'DeadNPCs':
        clause = 'status = "dead" and association != "AFAL"'
    else:
        raise NameError("Unknown kind " + str(kind))
    cur.execute("select char_name from fr_character "
 " where " + clause + " order by char_name")
    resp = cur.fetchall()
    _check_warnings()
    ret = []
    if len(resp) < 1 or len(resp[0]) != 1:
        return ret
    for i in resp:
        ret.append(i[0])
    return ret


def get_char_data(char):
    """ given a char, return its data """

    cur.execute("select fullname, player, gender, "
 " race, class, alignment, picture_url, equipment, "
 " char_acteristics, note, association, status, cash_cp, "
 " large_picture_url "
 " from fr_character where char_name = %(char)s",
 {'char':char})
    resp = cur.fetchall()
    _check_warnings()
    if len(resp) != 1:
        raise NameError("Couldn't find char '" + char + "'")
    resp = resp[0]
    ret = {}
    ret['name'] = char
    ret['fullname'] = resp[0]
    ret['player'] = resp[1]
    ret['gender'] = resp[2]
    ret['race'] = resp[3]
    ret['class'] = resp[4]
    ret['alignment'] = resp[5]
    ret['picture_url'] = resp[6]
    ret['equipment'] = resp[7]
    ret['characteristics'] = resp[8]
    ret['note'] = resp[9]
    ret['association'] = resp[10]
    ret['status'] = resp[11]
    ret['cash_cp'] = resp[12]
    ret['large_picture_url'] = resp[13]
    return ret


########## Parties


def get_party_data(party):
    """Given a party, return a list [[[name, share]...], shares] of its members"""

    cur.execute("select date, type, note from fr_party where party_name = %(party)s",
{'party':party})
    resp = cur.fetchall()
    _check_warnings()
    if len(resp) != 1 or len(resp[0]) != 3:
         raise NameError("party not found " + party)
    ret = {'name': party, 'date': date_to_str(resp[0][0]), 'type': resp[0][1], 'note': resp[0][2], 'members': {}}
    cur.execute("select char_name, share from fr_char_party where party_name = %(party)s",
{'party':party})
    resp = cur.fetchall()
    _check_warnings()
    if len(resp) < 1 or len(resp[0]) < 1:
         raise NameError("Members not found " + party)
    for i in resp:
        ret['members'][i[0]] = i[1]
    return ret


def get_char_parties(char):
    """Return a list of [party, share] that the character is in"""

    cur.execute("select fr_char_party.party_name, fr_char_party.share from "
 "fr_char_party natural join fr_party where fr_party.party_name != %(char)s"
 " and fr_char_party.char_name = %(char)s order by fr_party.date, fr_party.party_name",
 {'char':char})
    resp = cur.fetchall()
    _check_warnings()
    return resp


def get_parties():
    """Return a list of name entries for all the parties in the database"""

    cur.execute("select party_name from fr_party where type = 'AFAL' order by date, party_name")
    resp = cur.fetchall()
    _check_warnings()
    if len(resp) < 1 or len(resp[0]) < 1:
        return resp
    ret = []
    for i in resp:
        ret.append(i[0])
    return ret


def insert_party(d):
    """insert a party into the database"""

    _check_dict(d, must=('name', 'date', 'type', 'members'), may=('note',))
    party = d['name']
    date = str_to_date(d['date'])
    cur.execute(
 "insert into fr_party (party_name, type, date, note) values (%(party)s,"
 " %(type)s, %(date)s, %(note)s)", {'party':party, 'type':d['type'], 'date':date, 'note':d.get('note')})
    _check_warnings()
    for char in d['members'].keys():
        cur.execute( "insert into fr_char_party (char_name, party_name, share)"
" values ( %(char)s, %(party)s, %(share)s )",
 {'char': char, 'party': party, 'share': d['members'][char]})
        _check_warnings()


def char_leave_parties(date, char, note = None):
    """set the share of the specified character to 0 in all parties they were in"""

    cur.execute("update fr_char_party set share = 0 where char_name = %(char)s", {'char':char})
    _check_warnings()
    text = "{by} left AFAL"
    if note:
        text += ' ' + note
    journal(date, char, None, None, text)


########## Items


def insert_item(d):
    """insert an item into the database"""

    _check_dict(d, must=('item', 'finder', 'owner', 'holder', 'note',
 'value_cp', 'date_found', 'date_xfrd'), may=())
    item = d['item']
    d['date_found'] = str_to_date(d['date_found'])
    d['date_xfrd'] = str_to_date(d['date_xfrd'])
    cur.execute ( "select item_name from fr_item where item_name = %(item)s or item_name like %(with)s", {'item': item, 'with':item + '  #%%'})
    resp = cur.fetchall()
    _check_warnings()
    if len(resp) == 1:
        cur.execute("update fr_item set item_name = %(new)s where item_name = %(old)s",
 {'new': item + "  #1", 'old':item})
    if len(resp) > 0:
        item += "  #" + str(len(resp)+1)
        print "Warning: renaming item to", item
        d['item'] = item

    cur.execute(
 "insert into fr_item(item_name, found_by, owned_by, held_by, note, value_cp, date_found, date_xfrd)"
 " values(%(item)s, %(finder)s, %(owner)s, %(holder)s, %(note)s, %(value_cp)s, "
 " %(date_found)s, %(date_xfrd)s)", d)
    _check_warnings()


def get_item_data(item):
    """Get the data about an item"""

    cur.execute ( "select found_by, owned_by, held_by, date_found, date_xfrd, note, value_cp from fr_item where item_name = %(item)s",
 {'item':item})
    resp = cur.fetchall()
    _check_warnings()
    if resp is None or len(resp) != 1:
        return resp
    resp = resp[0]
    t = {}
    t['item'] = item
    t['finder'] = resp[0]
    t['owner'] = resp[1]
    t['holder'] = resp[2]
    t['date_found'] = date_to_str(resp[3])
    t['date_xfrd'] = date_to_str(resp[4])
    t['note'] = resp[5]
    t['value_cp'] = resp[6]
    return t


def change_item(date, item, owner=None, holder=None, value_cp = None, part_of = None):
    """Change the ownership, transfer date, and value_cp of an item"""

    date = str_to_date(date)
    c1 = ''
    if owner is not None:
        c1 += ",owned_by=%(owner)s"
    if holder is not None:
        c1 += ",held_by=%(holder)s"
    if value_cp is not None:
        c1 += ",value_cp=%(value_cp)s"

    cur.execute('update fr_item set date_xfrd=%(date)s' + c1 + ' where item_name=%(item)s',
 {'date':date, 'item':item, 'owner':owner, 'holder':holder, 'value_cp':value_cp })
    _check_warnings()


def get_items(kind, match = None):
    clause = ''
    if kind == 'Unresolved':
        clause = 'where owned_by = found_by and held_by is NULL'
    elif kind == 'Party':
        clause = 'where owned_by = %(party)s'
    elif kind == 'Auction':
        clause = 'where held_by = %(auction)s or note like "%%Auction%%"'
    elif kind == 'Sell':
        clause = 'where held_by = %(sell)s or note like "%%Sell%%"'
    elif kind == 'Lent':
        clause = 'where held_by is not NULL and held_by != owned_by'
    elif kind == 'Identify':
        clause = 'where note like "%%Identify%%"'
    elif kind == 'All':
        pass
    elif kind == 'Found_by':
        clause = 'where found_by = %(match)s'
    elif kind == 'Owned_by':
        clause = 'where owned_by = %(match)s'
    elif kind == 'Held_by':
        clause = 'where held_by = %(match)s'
    cur.execute("select "
 " item_name, found_by, owned_by, held_by, date_found, date_xfrd, note, value_cp "
 " from fr_item " + clause + " order by item_name",
 {'party':party, 'auction':auction, 'sell':sell, 'match':match})
    resp = cur.fetchall()
    _check_warnings()
    ret = []
    for i in resp:
        t = {}
        t['item'] = i[0]
        t['finder'] = i[1]
        t['owner'] = i[2]
        t['holder'] = i[3]
        t['date_found'] = date_to_str(i[4])
        t['date_xfrd'] = date_to_str(i[5])
        t['note'] = i[6]
        t['value_cp'] = i[7]
        ret.append(t)
    return ret


######## Debts


def get_char_debts(char, type):
    if type == 'Payable':
        clause = 'debtor = %(char)s'
        order = 'debtee'
    elif type == 'Receivable':
        clause = 'debtee = %(char)s'
        order = 'debtor'
    else:
        raise NameError("Unknown debt type " + type)
    text = 'select debt_id, debtor, debtee, repay_order, owed_cp, share, date, item, initial_cp from fr_debt where ' + clause + '  order by ' + order + ', repay_order'
    cur.execute(text , {'char':char})
    resp = cur.fetchall()
    _check_warnings()
    if resp is None or len(resp) == 0:
        return resp
    ret = []
    for i in resp:
        t = {}
        t['debt_id'] = i[0]
        t['by'] = i[1]
        t['to'] = i[2]
        t['order'] = i[3]
        t['amount_cp'] = i[4]
        t['share'] = i[5]
        t['date'] = date_to_str(i[6])
        t['item'] =  i[7]
        t['initial_cp'] = i[8]
        ret.append(t)
    return ret


def bump_debt_repay_order(debt_id):
    """increase the repay_order of the specified debt"""
    cur.execute ( "update fr_debt set repay_order = repay_order + 1 where debt_id = %(debt_id)s", {'debt_id':debt_id})
    _check_warnings()


def delete_debt(d):
    """Deletes the specified debt and journal it"""

    _check_dict(d, must=('debt_id', 'by', 'to', 'date', 'amount_cp', 'verb' ), may=('item', 'note', 'part_of'))
    cur.execute ( "delete from fr_debt where debt_id = %(debt_id)s", d )
    _check_warnings()
    text = '{by} ' + d['verb'] + ' a {amount} debt'
    if d['by'] != d['to']:
        text += ' to {to}'
    if d.get('item'):
        text += ' for ' + d['item']
    if d.get('note'):
        text += ' ' + d['note']
    journal(d['date'], d['by'], d['to'], d['amount_cp'], text, d.get('part_of'))

def debt_lower_owed(d):
    """Lower the amount owed on the specified debt and journal it"""

    _check_dict(d, must=('date', 'by','to', 'amount_cp', 'debt_id', 'lower_cp', 'verb'), may=('item', 'note', 'part_of'))
    cur.execute("update fr_debt set owed_cp = owed_cp - %(lower_cp)s "
 " where debt_id = %(debt_id)s", {'lower_cp':d['lower_cp'], 'debt_id':d['debt_id']})
    _check_warnings()
    text = '{by} ' + d['verb'] + ' {amount} of a ' + cp_to_str(d['amount_cp']) + ' debt to {to}'
    if d.get('item'):
        text += ' for ' + d['item']
    text += ', leaving ' + cp_to_str(d['amount_cp'] - d['lower_cp'])
    if d.get('note'):
        text += ' ' + d['note']
    journal(d['date'], d['by'], d['to'], d['lower_cp'], text, d.get('part_of'))


def insert_debt(d):
    """insert a debt into the database and journal it"""

    _check_dict(d, must=('date', 'by', 'to', 'amount_cp'), may=('repay_order','share','part_of', 'item', 'note'))
    if 'repay_order' not in d:
        d['repay_order'] = 0
    if 'share' not in d:
        d['share'] = 1.0
    if 'part_of' not in d:
        d['part_of'] = None
    if 'item' not in d:
        d['item'] = None

    by = d['by']
    to = d['to']
    d['date'] = str_to_date(d['date'])
    if by == to:
        text = "{by} noted a self-debt of {amount}"
        if d.get('item'):
            text += " for " + d['item']
        if d.get('note'):
            text += ' ' + d['note']
        journal(d['date'], by, None, d['amount_cp'], text, d['part_of'])
        return

    cur.execute("insert into fr_debt "
 " (date,debtee,debtor,repay_order,share,item,initial_cp,owed_cp) "
 " values(%(date)s, %(by)s, %(to)s, %(repay_order)s, %(share)s, %(item)s, "
 " %(amount_cp)s, %(amount_cp)s)", d)
    _check_warnings()

    text = "{by} lent {amount} to {to}"
    if d['repay_order'] != 0:
        text += " repay order " + str(d['repay_order'])
    if d['share'] != 1.0:
        text += " for " + share_to_str(d['share']) + " share"
    if d.get('item'):
        text += " for " + d['item']
    if d.get('note'):
        text += ' ' + d['note']
    journal(d['date'], by, to, d['amount_cp'], text, d['part_of'])

######## End
