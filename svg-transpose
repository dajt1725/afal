#!/usr/bin/python
import argparse
from xml.dom.minidom import parse, parseString
import re

unneeded_attributes = {
 'inkscape:connector-curvature': re.compile('^0$'),
 'sodipodi:nodetypes': re.compile('^c*$'),
 'inkscape:label': re.compile('^$|^[^U]')
}

###### path parsing code
style_to_class = {
 'fill:#edd567;stroke:none': 'corr',
 'fill:#edb667;stroke:none': 'room',
 'fill:#0000ff;stroke:#ffff00;stroke-width:0.5px': 'feature-water',
 'fill:url(#pattern-stairs-ew);stroke:none': 'stairs-ew',
 'fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1': 'wall',
 'fill:#e2c022;stroke:#000000;stroke-width:0.5px': 'door',
 'fill:url(#pattern-stairs-ns);stroke:none': 'stairs-ns',
 'fill:#ffa500;stroke:#ffff00;stroke-width:0.5px': 'feature',
 'font-size:6px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans;-inkscape-font-specification:Sans': 'name',
 'fill:#ff0000;stroke:#ffff00;stroke-width:0.5px': 'feature-bad',
 'fill:#683910;stroke:#000000;stroke-width:0.5px': 'sec-door',
 'fill-opacity:1;stroke:#feff04;stroke-opacity:1': 'door',
 'fill:none;stroke:#ffff00;stroke-width:2px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1': 'feature-path',
 'fill:#808080;fill-opacity:1;stroke:#ffff00;stroke-width:1;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none': 'pit',
 'fill:#edb667;fill-opacity:1;stroke:#000000;stroke-width:1;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none': 'room-alt',
 'fill:#ffff00;stroke:none': 'floor-sand',
 'fill:#ed7767;stroke:none': 'floor-null-magic',
 'fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:3, 1;stroke-dashoffset:0': 'bars',
 'fill:#000000;stroke:none': 'column',
 'fill:#800080;stroke:#ffff00;stroke-width:0.5px': 'feature-purple',
 'fill:#008000;stroke:#ffff00;stroke-width:0.5px': 'feature-green'
}

p_nargs = {
 'a': 7, 'c': 6, 'h': 1, 'l': 2, 'm': 2, 'q': 4, 's': 4, 't': 2, 'v': 1, 'z': 0
}
p_num = r'(-?\d*\.?\d+)'
p_sep = r'\s*,?\s*'
p_regex = r'\s*('
for l in p_nargs.keys():
    if len(p_regex) > 4:
        p_regex += '|'
    if p_nargs[l] > 1:
        p_regex += r'\s*[{l1}{l2}](({s}{n}){{{r}}})+'.format(l1 = l, l2 = l.upper(),
s = p_sep, n = p_num, r = p_nargs[l])
    elif p_nargs[l] == 1:
        p_regex += r'\s*[{l1}{l2}]({s}{n})+'.format(l1 = l, l2 = l.upper(),
s = p_sep, n = p_num)
    else:
        p_regex += r'\s*[{l1}{l2}]'.format(l1 = l, l2 = l.upper())
p_regex += r')\s*'
p_re = re.compile(p_regex)

def _xp_1p(m):
    p = m.group(1)
    if p == '':
        p = ' '
    x = transpose_path.dx + float(m.group(2))
    if x == float(int(x)):
        x = int(x)
    y = transpose_path.dy + float(m.group(3))
    if y == float(int(y)):
        y = int(y)
    return '{p}{x} {y}'.format(p = p, x = x, y = y)

def _xp_np(m):
    return m.group(1) + re_sub(r'(\s*,?\s*)(-?\d*\.?\d+)\s*,?\s*(-?\d*\.?\d+)', _xp_1p, m.group(2))

def _xp_1s(m):
    n = transpose_path.d + float(m.group(1))
    if n == float(int(n)):
        n = int(n)
    return ' {n}'.format(n = n)

def _xp_ns(m):
    return m.group(1) + re.sub(r'\s*,?\s*(-?\d*\.?\d+)', _xp_1s, m.group(2))

def _xp_na(m):
    return 'A'+re.sub(r'(\s*,?\s*-?\d*\.?\d+\s*,?\s*-?\d*\.?\d+\s*,?\s*-?\d*\.?\d+\s*,?\s*-?\d*\.?\d+\s*,?\s*-?\d*\.?\d+)(\s*,?\s*-?\d*\.?\d+)(\s*,?\s*-?\d*\.?\d+)', _xp_1p, m.group(1))

# take a textual path, and transpose it by dx,dy.  This requires modifying
# all absolute addresses appropriately.
def transpose_path(p,dx,dy):
    transpose_path.dx = dx
    transpose_path.dy = dy
    p_new = re.sub(r'^(m\s*)(-?\d*\.?\d+)\s*,?\s*(-?\d*\.?\d+)', _xp_1p, p)
    p_new = re.sub(r'([CSMLQT])((\s*,?\s*-?\d*\.?\d+\s*,?\s*-?\d*\.?\d+)+)', _xp_np, p_new)
    transpose_path.d = dx
    p_new = re.sub(r'(H)(\s*,?\s*-?\d*\.?\d+)+', _xp_ns, p_new)
    transpose_path.d = dx
    p_new = re.sub(r'(V)(\s*,?\s*-?\d*\.?\d+)+', _xp_ns, p_new)
    p_new = re.sub(r'A((\s*,?\s*-?\d*\.?\d+){7})+', _xp_na, p_new)
    return p_new

# take a textual path, and return a list of lists, where each sublist
# is one path command and its arguments.  If a command in the path has
# multiple groups of arguments, it turns into multiple sublists, one
# for each set of arguments.
# z commands are not put in sublists, but stored bare in the list.

def path_to_list(p):
#    print p_regex
    ret = []
    while len(p) > 0:
#        if args.verbose:
#            print "to_list '"+p+"'"
        m = re.match(p_re, p)
        if m is None or len(m.group(0)) == 0:
            raise ValueError("Invalid path '"+p+"'")
        s = m.group(0)
#        if args.verbose:
#            print "matched '"+s+"'"
        p = p[len(s):]
        n = re.match(r'\s*([aAcChHlLmMqQsStTvVzZ])(.*?)\s*$', s)
        if n is None:
            raise ValueError("Invalid command "+s)
        t = n.group(0)
        c = n.group(1)
        s = n.group(2)
        if len(s)==0:
            ret.append(c)
        while len(s) > 0:
#            if args.verbose:
#                print "args '"+s+"'"
            v = [c]
            if c == 'm':
                c = 'l'
            elif c == 'M':
                c = 'L'
            for i in range(p_nargs[c.lower()]):
                m3 = re.match(r'{s}({n})\s*'.format(s=p_sep,n=p_num),s)
                if m3 is None:
                    raise ValueError("Invalid number '" + s + "'")
                s = s[len(m3.group(0)):]
                r = m3.group(2)
                if '.' in r:
                    v.append(float(r))
                else:
                    v.append(int(r))

            if len(v)>0:
                ret.append(v)
    return ret

# takes a path list (as created by path_to_list) and turns all the
# absolute positioning commands into relative ones.
def abs_list_to_rel(l):
    cx = 0
    sx = 0
    cy = 0
    sy = 0
    ret = []
    for i in l:
#        if args.verbose:
#            print "i '"+repr(i)+"'"
        if i[0].isupper():
            c = i[0].lower()
            i[0] = c
            if c == 'a':
                i[6] -= cx
                i[7] -= cy
            elif c == 'c':
                i[1] -= cx
                i[2] -= cy
                i[3] -= cx
                i[4] -= cy
                i[5] -= cx
                i[6] -= cy
            elif c == 'h':
                i[1] -= cx
            elif c == 'l' or c == 'm' or c == 't':
                i[1] -= cx
                i[2] -= cy
            elif c == 'q' or c == 's':
                i[1] -= cx
                i[2] -= cy
                i[3] -= cx
                i[4] -= cy
            elif c == 'v':
                i[1] -= cy
        else:
            c = i[0]
        ret.append(i)
        if c == 'a':
            cx += i[6]
            cy += i[7]
        elif c == 'c':
            cx += i[5]
            cy += i[6]
        elif c == 'h':
            cx += i[1]
        elif c == 'l' or c == 't':
            cx += i[1]
            cy += i[2]
        elif c == 'q' or c == 's':
            cx += i[3]
            cy += i[4]
        elif c == 'v':
            cy += i[1]
        elif c == 'm':
            cx += i[1]
            cy += i[2]
            sx = cx
            sy = cy
        elif c == 'z':
            cx = sx
            cy = sy
        else:
            raise ValueError("unknown command "+c)
    return ret

# takes a list and returns a list with all the absolute elements moved by dx,dy
# This is much easier than transposing a path

def transpose_list(l,dx,dy):
    ret = []
    if l[0][0] == 'm':
        l[0][1] += dx
        l[0][2] += dy
    for i in l:
        if i[0] == 'M' or i[0] == 'L' or i[0] == 'T' or i[0] == 'C' or i[0] == 'Q' or i[0] == 'S':
            for j in range(1,len(i),2):
                i[j]+= dx
                i[j+1] += dy
        elif i[0] == 'H':
             for j in range(1,len(i)):
                 i[j] += dx
        elif i[0] == 'V':
             for j in range(1,len(i)):
                 i[j] += dy
        elif i[0] == 'A':
             for j in range(1,len(i),7):
                 i[j+5] += dx
                 i[j+6] += dy
        ret.append(i)
    return ret

# takes a list and produces an optimized list
def optimize_list(l):
    ret = []
    i = 0
    while i < len(l):
        t = l[i]
        j = i + 1
        if t[0] == 'l':
            if t[1] == 0:
                t = ['v', t[2]]
            elif t[2] == 0:
                t = ['h', t[1]]
        while j < len(l):
            m = l[j][0]
            if (m != 'l' or (l[j][1] != 0 and l[j][2] != 0)) and (( t[0] == 'm' and l[j][0] == 'l' ) or t[0] == l[j][0]):
                for k in l[j][1:]:
                    t.append(k)
                j += 1
            else:
                break
        ret.append(t)
        i = j
    return ret


# takes a path list (as created by path_to_list) and produces a text
# representation of it
def list_to_path(l):
    ret = ''
    s = ' '
    needs = False
    for i in l:
        for j in i:
            j = str(j)
            if needs and j[0].isdigit():
                j = s + j
            ret += j
            if j[-1].isdigit():
                needs = True
            else:
                needs = False
    return ret


####### xy transform

def fixd2(m):
#    if args.verbose:
#        print "fixd2",m.group(1),m.group(2)
    return m.group(1)+re.sub(r'(\s*)(-?\d+\.?\d*)(\s*|,)(-?\d+\.?\d*)', fixd1, m.group(2))

def upd(n,a,d):
    v = n.getAttribute(a)
    if v is not None and v != '':
        t = float(v)+d
        if t == float(int(t)):
            t = int(t)
        if args.verbose:
            print "updating",a,'(',v,')','by',d,'to',t
        n.setAttribute(a,str(t))

def do_update(n,dx,dy):
# We never update patterns
    if n.nodeName == 'pattern':
        return
# We ignore p elements, but update their children
    if n.attributes and n.nodeName != 'p':
        if args.verbose:
            print n.nodeName,n.getAttribute("id")
        if args.unneeded:
            for attr_name in unneeded_attributes.keys():
                attr = n.attributes.getNamedItem(attr_name)
                if not attr or not unneeded_attributes[attr_name].search(attr.value):
                    continue
#                print "a",a
                if args.verbose:
                    print "removing",attr.name,attr.value
                n.attributes.removeNamedItem(attr_name)
        if args.style:
            ele_class = n.attributes.getNamedItem('class')
            ele_style = n.attributes.getNamedItem('style')
            if args.verbose and ele_class:
                print "class",ele_class.specified,ele_class.value
            if args.verbose and ele_style:
                print "style", ele_style.specified,ele_style.value
            if ele_style and ele_style.value != '':
                if not ele_class or ele_class.value == '':
                   t = style_to_class.get(ele_style.value)
                   if t:
                       if args.verbose:
                           print "Replacing style", ele_style.value, "with class", t
                       n.setAttribute('class',t)
                       n.removeAttribute('style')
                   else:
                       print "No known class for style", ele_style.value
                elif style_to_class.get(ele_style.value) == ele_class.value:
                    if args.verbose:
                        print "removing style",ele_style.value,"for class",ele_class.value
                    n.removeAttribute('style')
                else:
                    print "style ",ele_style.value, "!= class style for",ele_class.value
        t = n.getAttribute('transform')
        if t is not None and t!= '':
            r = re.match(r'translate\((-?\d+\.?\d*),(-?\d+\.?\d*)\)$',t)
            if r:
                dx += float(r.group(1))
                dy += float(r.group(2))
                n.removeAttribute('transform')
            else:
                print "Unknown transform",t
        if dx != 0:
            upd(n,'x',dx)
            upd(n,'cx',dx)
            upd(n,'sodipodi:cx',dx)
        if dy != 0:
            upd(n,'y',dy)
            upd(n,'cy',dy)
            upd(n,'sodipodi:cy',dy)
        d = n.getAttribute('d')
        if d is not None and d != '':
            if args.path:
#                print n.nodeName,n.getAttribute("id")
#                print "original path '" + d + "'"
                l = path_to_list(d)
#                print "list",l
                l = abs_list_to_rel(l)
#                print "rel",l
                l = optimize_list(l)
#                print "optimized",l
                if dx != 0 or dy != 0:
                    l = transpose_list(l,dx,dy)
#                    print "transposed",l
                d_new = list_to_path(l)
            elif dx!= 0 or dy!= 0:
                d_new = transpose_path(d,dx,dy)
            else:
                d_new = None
            if d_new:
                if args.verbose:
                    print n.nodeName,n.getAttribute("id"),'"'+d+'"','"'+d_new+'"'
                n.setAttribute('d',d_new)
#    elif args.verbose:
#        print n.nodeName
    for i in n.childNodes:
        do_update(i,dx,dy)

parser = argparse.ArgumentParser("transform the specified svg file by the specified amounts")
parser.add_argument("--verbose", "-v", help = "print progress messages", action = 'store_true', default = False)
parser.add_argument("--unneeded", "-u", help = "remove unneeded attributes elements", action = 'store_true', default = False)
parser.add_argument("--style", "-s", help = "remove/edit style elements", action = 'store_true', default = False)
parser.add_argument("--path", "-p", help = "edit paths", action = 'store_true', default = False)
parser.add_argument('--x', '-x', type=int, default=0, help='translate x by')
parser.add_argument('--y', '-y', type=int, default=0, help='translate y by')
parser.add_argument("infile", help = "file to read")
parser.add_argument("outfile", help = "file to write")
args = parser.parse_args()

a = parse(args.infile)
for i in a.childNodes:
    do_update(i, args.x, args.y)
f = open(args.outfile, 'w')
a.writexml(f)
f.close()
