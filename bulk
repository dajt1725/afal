#!/usr/bin/python
import argparse
import afal
import os
import sys

# if may is None, don't check for extra keys at all
def check_dict(d, must = None, may = None):
    """ dict must contain every element in 'must', and may contain elements in 'may'"""

    if may is not None:
        for i in d:
            if i not in must and i not in may:
                sys.stderr.write("\nUnexpected key {i} found in dict {d} only expected must={must}, may={may}\n".format(i=i, d=d, must=must, may=may))
                raise NameError("Unexpected key '"+i+"'")

    for i in must:
        if not i in d:
            sys.stderr.write("\nMissing key {i} in dict {d} expected must={must}\n".format(i=i, d=d, must=must))
            raise NameError("Missing key '"+i+"'")



def do_meet(d):
    check_dict(d, must=('name','status'), may=('alignment', 'association',
'characteristics', 'class', 'hidden_note', 'equipment', 'fullname', 'note',
 'player', 'race', 'picture', 'large_picture', 'cash', 'gender', 'joined', 'date'))
    e = {}
    for i in ('name', 'status', 'alignment', 'association', 'characteristics',
 'class', 'hidden_note', 'equipment', 'fullname', 'note', 'player',
 'race', 'picture', 'large_picture', 'gender'):
        e[i] = d.get(i)
    if 'cash' in d:
        e['cash'] = d['cash']
    if args.verbose:
        print "Creating character", e
    afal.insert_character(e)
# Every character is in a party of just themselves
# This is primarily to prevent someone accidentally creating a party and a
# character with the same names
    if 'date' in d:
        date = d['date']
    elif 'joined' in d:
        date = d['joined']
    else:
        date = None
    afal.insert_party({'name':d['name'], 'type': 'Character', 'date': date, 'members':{d['name']:1}})


def do_party(d):
    check_dict(d, must=('name','type'))
    e = {}
    e['name'] = d.pop('name')
    e['type'] = d.pop('type')
    if 'date' in d:
        e['date'] = d.pop('date', None)
    else:
        e['date'] = afal.party_to_date(e['name'])
    if 'note' in d:
        e['note'] = d.pop('note')
    e['members'] = {}
    for c in d:
        e['members'][c] = d[c]
    if args.verbose:
        print "creating party", e
    afal.insert_party(e)


def do_give(d):
    # Two possibilities from=, amount= to move cash
    # or item= to give an item
    if 'item' in d:
        check_dict(d, must = ('date', 'to', 'item'), may=('journal', 'note', 'part_of'))
        if args.verbose:
            print "giving item", d
        afal.change_item(d['date'], d['item'], owner = d['to'], holder = d['to'], part_of = d.get('part_of'))
        return
    if 'cash' in d:
        check_dict(d, must=('date', 'to', 'by', 'cash'), may=('for', 'note', 'part_of'))
        if args.verbose:
            print "giving cash", d
        d['cash'] = afal.str_to_coins(d['cash'])
    else:
        check_dict(d, must=('date', 'to', 'by', 'amount'), may=('for', 'note', 'part_of'))
        if args.verbose:
            print "giving money", d
        d['amount_cp'] = afal.str_to_cp(d.pop('amount'))
    afal.chars_move_cash(d)


def do_lend(d):
    date=d['date']
    to = d['to']
    part_of = d.get('part_of')
    if 'item' in d:
        check_dict(d, must = ('date', 'to', 'item'), may = ('note', 'part_of'))
        if args.verbose:
            print "lending item", d
        afal.change_item(date, d['item'], holder=to, part_of = part_of)
        return
    check_dict(d, must=('date', 'to', 'by', 'amount'), may = ('virtual', 'for', 'note', 'part_of', 'journal'))
    if args.verbose:
        print "lending cash", d
    by = d['by']
    amount_cp = afal.str_to_cp(d['amount'])
    party_data = afal.get_party_data(by)
    lenders = party_data['members']
    shares = sum(lenders.values())
    if shares == 1:
        even_cp = amount_cp
    else:
        share_mult = 1
        for share in lenders.values():
            if share > 0 and 1/share > share_mult:
                share_mult = int(1/share)
        even_cp = shares * share_mult * int(amount_cp/(shares*share_mult))
        even_cp = int(even_cp)
        if even_cp != amount_cp:
           sys.stderr.write("Even shares would be lending {even} not {amount} for shares of {even_shares} with {leftover} unaccounted for in {d}\n".format(
even=afal.cp_to_str(even_cp), amount=afal.cp_to_str(amount_cp), even_shares = afal.cp_to_str(int(even_cp/shares)), leftover = afal.cp_to_str(amount_cp-even_cp),d=d))
    if len(lenders) > 1 and d.get('journal',True):
        text = "{each}lent {virtual} to {to}"
        if d.get('note'):
            text += ' ' + d['note']
        tmp = afal.journal(date, by, to, None, amount_cp, text, part_of )
        if part_of is None:
            part_of = tmp
    journaled = {}
    journ_by = {}
    for by in lenders:
        share = float(lenders[by])
        if share == 0.0:
            continue
        share_cp = afal.divide_cp(share, amount_cp, shares)
        amount_cp -= share_cp
        shares -= share
        if by == to:
            text = "noted a self-debt of {virtual}"
            totmp = None
        else:
            text = "{each}lent {virtual} to {to}"
            totmp = to
        fer = " for "
        if share != 1.0:
            text += fer + afal.share_to_str(share) + " share"
            fer = " of "
        if d.get('for'):
            text += fer + d['for']
        if d.get('note'):
            text += ' ' + d['note']
        if text in journaled:
            afal.journal_add_by(journaled[text], by)
        else:
            journaled[text] = afal.journal(date, by, totmp, None, share_cp, text, part_of)

        if totmp is not None:
            afal.insert_debt({'date':date, 'by':by, 'to':to,
 'amount_cp':share_cp, 'share':share, 'item':d.get('for')})
            if 'virtual' not in d:
                afal.chars_move_cash({'date':date, 'by':by, 'to':to, 'amount_cp':share_cp, 'part_of':part_of, 'journal': d.get('journal',True), 'journ_by':journ_by})


def do_sell(d):
    check_dict(d, must=('date', 'to', 'item'), may=('cash', 'debt', 'note', 'part_of', 'virtual'))
    date = d['date']
    to = d['to']
    cash_cp = afal.str_to_cp(d.get('cash'))
    if cash_cp is None:
        cash_cp = 0
    debt_cp = afal.str_to_cp(d.get('debt'))
    if debt_cp is None:
        debt_cp = 0
    item = d['item']
    item_data = afal.get_item_data(item)
    note = d.get('note','')
    part_of = d.get('part_of')
    if item_data is None or len(item_data) < 2 or (cash_cp == 0 and debt_cp == 0):
        sys.stderr.write("\nIgnoring invalid sell command {d}\n".format(d = d))
        return
    seller = item_data['owner']
    if cash_cp > 0:
        t_for = '{cash} cash'
        t_and = ' and '
    else:
        t_for = ''
        t_and = ''
    if debt_cp > 0:
        t_for += t_and + '{virtual} debt'
    text = 'sold {item} to {{to}} for {fer}{note}'.format(item=item, fer=t_for,note=note)
    tmp = afal.journal(date, seller, to, cash_cp, debt_cp, text, part_of)
    if part_of is None:
        part_of = tmp
    afal.change_item(date, item, owner = to, holder = to, value_cp = cash_cp + debt_cp, part_of = part_of )

    if debt_cp > 0:
        do_lend({'by':seller, 'to':to, 'amount': afal.cp_to_str(debt_cp), 'date':date, 'for':item, 'part_of':part_of, 'note':note, 'virtual':True, 'journal':False})
    if 'virtual' not in d and cash_cp > 0:
        do_give({'date':date, 'by':to, 'to':seller, 'cash': d.get('cash'), 'for':item, 'part_of':part_of, 'note':note})


def do_pay(d):
    inexact = False
    item = None
    coins = None
    if 'item' in d:
        check_dict(d, must=('date', 'to', 'item'), may=('note','part_of'))
        item = d['item']
        item_data=afal.get_item_data(item)
        by = item_data['owner']
        amount_cp = item_data['value_cp']
    elif 'cash' in d:
        check_dict(d, must=('date', 'by', 'cash', 'to'), may=('note', 'part_of'))
        by = d['by']
        coins = afal.str_to_coins(d['cash'])
        amount_cp = coins['value_cp']
    elif 'by' in d:        
        check_dict(d, must=('date', 'by'), may=('amount_cp', 'amount', 'percent', 'virtual', 'to', 'note', 'part_of'))
        by = d['by']
        if d.get('amount_cp'):
            amount_cp = d['amount_cp']
        elif d.get('amount'):
            amount_cp = afal.str_to_cp(d['amount'])
        elif 'percent' in d:
            amount_cp =  int(float(afal.get_char_data(by)['cash_cp']) * float(d['percent'])/100.0)
            inexact = True
        else:
            amount_cp = afal.get_char_data(by)['cash_cp']
            inexact = True
    else:
        sys.stderr.write("\nIgnoring invalid pay command {d}\n".format(d = d))
        return
    payable = afal.get_char_debts(by, 'Payable')
    if len(payable) == 0:
        sys.stderr.write("\n{by} has not debts to pay\n".format(by=by))
        return
    if 'to' in d:
        to = d['to']
        ptmp = []
        for i in payable:
            if i['to'] == to:
                ptmp.append(i)
        payable = ptmp
    else:
        to = payable[0]['to']
        for debt in payable[1:]:
           if debt['to'] != to:
               to = 'debts'
               break

    date = d['date']
    shares = 0.0
    owed = 0
    for i in payable:
        shares += i['share']
        owed += i['amount_cp']
    if amount_cp > owed:
        if not inexact:
            if amount_cp - owed < 3:
                sys.stderr.write("\nWARNING: lost track of a cp or two: {by} {to} {lost}\n".format( by = by, to = to, lost = amount_cp - owed))
            else:
                sys.stderr.write("\nWARNING: {by} only owes {owed} not {amount}\n".format(by = by, owed=afal.cp_to_str(owed), amount=afal.cp_to_str(amount_cp)))
        amount_cp = owed
    if item:
        cash = None
        virtual = amount_cp
        text = 'paid {virtual} {each}to {to} with ' + item
    elif coins is not None:
        cash = amount_cp
        virtual = None
        text = 'paid {cash} {each}to {to} with {cs}' + afal.coins_to_str(coins)+'{ce}'
    else:
        cash = amount_cp
        virtual = None
        text = 'paid {cash} {each}to {to}'
    note = d.get('note')
    if note:
        text += ' ' + note
    part_of = d.get('part_of')
    tmp = afal.journal(date, by, to, cash, virtual, text, part_of)
    if part_of is None:
        part_of = tmp
    topay = {}
    todel = {}
    tolower = {}
    journ_to = {}
    for i in payable:
        this_owed = i['amount_cp']
        this_share = i['share']
        to = i['to']
        this_cp = afal.divide_cp(this_owed, amount_cp, owed)
        if abs(this_cp - this_owed) < 3:
            if this_cp != this_owed:
                sys.stderr.write("\nWARNING: lost track of a cp or two: {by} {to} {lost}\n".format(by = i['by'], to = i['to'], lost = this_cp-this_owed))
            tmp = {'date':date, 'debt_id':i['debt_id'], 'by':i['by'], 'to':i['to'], 'amount_cp':i['amount_cp'], 'item':i.get('item'), 'part_of':part_of, 'note':note, 'verb': 'paid off'}
            if to in todel:
                todel[to].append(tmp)
            else:
                todel[to] = [tmp]
        else:
            tmp = {'date':date, 'debt_id': i['debt_id'], 'by':i['by'], 'to': i['to'], 'amount_cp': i['amount_cp'],
 'part_of': part_of, 'note': note, 'lower_cp': this_cp, 'verb': 'paid'}
            if 'item' in i:
                tmp['item'] = i['item']
            if to in tolower:
                tolower[to].append(tmp)
            else:
                tolower[to] = [tmp]
        if item is None and 'virtual' not in d:
            if to in topay:
                topay[to]['amount_cp'] += this_cp
            else:
                tmp = {'date': date, 'by': by, 'to': to,
 'amount_cp': this_cp, 'journ_to':journ_to}
                if 'to' in d:
                    tmp['journal'] = False
                if coins is not None:
                    tmp['cash'] = coins
                if part_of is not None:
                    tmp['part_of'] = part_of
                if note is not None:
                    tmp['note'] = note
                if len(payable) == 1:
                    if 'item' in i:
                        tmp['item'] = i['item']
                    if 'for' in i:
                        tmp['for'] = i['for']
                topay[to] = tmp
        amount_cp -= this_cp
        owed -= this_owed
        shares -= this_share

    if item is not None:
        part_of = afal.change_item(date, item, owner = to, holder = to, part_of = part_of)
        if to in todel:
            for j in todel[to]:
                j['part_of'] = part_of
        if to in tolower:
            for j in tolower[to]:
                j['part_of'] = part_of
    elif 'virtual' not in d:
        for i in topay:
            part_of = afal.chars_move_cash(topay[i])
            if i in todel:
                for j in todel[i]:
                    j['part_of'] = part_of
                    afal.delete_debt(j)
                del todel[i]
            if i in tolower:
                for j in tolower[i]:
                    j['part_of'] = part_of
                    afal.debt_lower_owed(j)
                del tolower[i]
    for i in todel:
        for j in todel[i]:
            afal.delete_debt(j)
    for i in tolower:
        for j in tolower[i]:
            afal.debt_lower_owed(j)


def do_writeoff(d):
    check_dict(d, must=('date',))
    date = d.pop('date')
    part_of_main = d.pop('part_of', None)
    note = d.pop('note', None)
    for char in d:
        payable = afal.get_char_debts(char, 'Payable')
        receivable = afal.get_char_debts(char, 'Receivable')
        if len(payable) > 0 or len(receivable)>0:
            pay_cp = 0
            for debt in payable:
                pay_cp += debt['amount_cp']
            rec_cp = 0
            for debt in receivable:
                rec_cp += debt['amount_cp']
            if pay_cp > 0 and rec_cp > 0:
                text = 'cancelled '+afal.cp_to_str(rec_cp)+' and welshed on '+afal.cp_to_str(pay_cp)+' of debts'
            elif pay_cp > 0:
                text = 'welshed on {virtual} of debt'
            else:
                text = 'cancelled {virtual} of debt'
            if note:
                text += ' ' + note
            tmp = afal.journal(date, char, None, None, pay_cp + rec_cp, text, part_of_main)
            part_of = tmp if part_of_main is None else part_of_main
            journaled = {}
            for debt in payable:
                afal.delete_debt({'date':date, 'debt_id':debt['debt_id'], 'by':char, 'to':debt['to'], 'amount_cp':debt['amount_cp'], 'item':debt.get('item'), 'part_of':part_of, 'note':note, 'verb': 'welshed on', 'journaled': journaled})
            journaled = {}
            for debt in receivable:
                afal.delete_debt({'date':date, 'debt_id':debt['debt_id'], 'by':debt['by'], 'to':char, 'amount_cp':debt['amount_cp'], 'item':debt.get('item'), 'part_of':part_of, 'note':note, 'verb': 'cancelled', 'journaled': journaled})
        afal.char_leave_parties(date, char, note)


def scale_cash(d,share):
    ret = {}
    for i in d:
        if d[i] * share != int(d[i] * share):
            raise ValueError("cash {n} {i} doesn't scale by {share}".format(n=d[i],i=i,share=share))
        ret[i] = int(d[i] * share)
#    print "scale cash", d, "to", ret, "by", share
    return ret

def do_dividend(d):
    check_dict(d, must=('date','by'), may=('cash', 'amount', 'note', 'part_of'))
    date = d['date']
    by = d['by']
    party_data = afal.get_party_data(by)
    part_of = d.get('part_of')
    members = party_data['members']
    shares = float(sum(members.values()))
    share_mult = 1
    for share in members.values():
        if share > 0 and 1/share > share_mult:
            share_mult = int(1/share)
    text = "paid a dividend of {cash}"
    if 'amount' in d:
        if 'cash' in d:
            raise ValueError("Can't have both cash and amount")
        amount_cp = afal.str_to_cp(d['amount'])
        cash = None
        even_cash = None
        if shares == 1:
            even_cp = amount_cp
        else:
            even_cp = shares * share_mult * int(amount_cp/(share_mult * shares))
            even_cp = int(even_cp)
            if amount_cp != even_cp:
                text += "(and {cp} to the party)".format(cp = afal.cp_to_str(amount_cp-even_cp))
            text += " split into {sh} shares of {{cs}}{ea}{{ce}} each".format(sh = afal.share_to_str(shares), ea = afal.cp_to_str(int(even_cp/shares)))
    elif 'cash' in d:
        cash = afal.str_to_coins(d['cash'])
        if shares == 1:
            even_cash = cash
            even_cp = cash['value_cp']
        else:
	    even_cash = {'value_cp': 0}
            rem_cash = {'value_cp': 0}
            for coin in cash:
                if coin == 'value_cp':
                    continue
                even_coin = int(shares * share_mult * int(cash[coin]/(shares*share_mult)))
                even_cash[coin] = int(even_coin/shares)
                if cash[coin] != even_coin:
                    rem_cash[coin] = cash[coin] - even_coin
                    rem_cash['value_cp'] += rem_cash[coin] * afal.coins_byname[coin]['copper_equiv']
                even_cash['value_cp'] += even_cash[coin] * afal.coins_byname[coin]['copper_equiv']
            if rem_cash['value_cp'] > 0:
                text += "(and {cash} to the party)".format(cash=afal.coins_to_str(rem_cash))
            text += " split into {sh} shares of {{cs}}{ea}{{ce}} each".format(sh = afal.share_to_str(shares), ea = afal.coins_to_str(even_cash))
            even_cp = even_cash['value_cp'] * shares
    else:
        raise ValueError("Need either cash or amount")
    if shares != len(members):
        text += " among {n} party members".format(n = len(members))
    if d.get('note'):
        text += ' ' + d['note']
    tmp = afal.journal(date, by, members.keys(), even_cp, None, text, part_of)
    if part_of is None:
        part_of = tmp
    journ_to = {}
    for char in members:
        share = members[char]
        if share == 0:
            continue
        if even_cash:
            afal.chars_move_cash({'date':date, 'cash':scale_cash(even_cash, share),
'by':by, 'to':char, 'part_of':part_of, 'journ_to': journ_to})
        else:
            share_cp = afal.divide_cp(share, even_cp, shares)
            if args.verbose:
                print afal.cp_to_str(share_cp), "to", char
            afal.chars_move_cash({'date':date, 'amount_cp':share_cp,
'by':by, 'to':char, 'part_of':part_of, 'journ_to': journ_to})
            even_cp -= share_cp
            shares -= share


def do_cancel(d):
    check_dict(d, must=('date',))
    date = d.pop('date')
    note = d.pop('note', None)
    for char in d:
        payable = afal.get_char_debts(char, 'Payable')
        receivable = afal.get_char_debts(char, 'Receivable')
        if len(payable) == 0 or len(receivable) == 0:
            continue
        part_of = afal.journal(date, char, None, None, None, "cancelled debts")

# payable holds a list of of who we owe money to, sorted by who we owe it to
# receivable holds a list of who owes us money, sorted by who they are
        rec_start = 0
        while len(payable)> 0 and rec_start < len(receivable):
            if payable[0]['to'] < receivable[rec_start]['by']:
                payable = payable[1:]
                continue
            if receivable[rec_start]['by'] < payable[0]['to']:
                rec_start += 1
                continue
# if we get here we've found a pair of debts to/from the same person
# Now figure out how many debts of each type we have with that person
            pay = payable[0]['to']
            pay_order = payable[0]['order']
            pay_end = 0
            while pay_end < len(payable) - 1:
                if payable[pay_end+1]['to'] != pay or payable[pay_end+1]['order'] != pay_order:
                    break
                pay_end += 1
            pay_cp = 0
            for i in range(0,pay_end+1):
                pay_cp += payable[i]['amount_cp']

            rec = receivable[rec_start]['by']
            if rec != pay:
                sys.stderr.write("\n ERROR rec {rec} and pay {pay} ids don't match for {char}\n".format(rec= rec, pay = pay, char=char))
                return
            rec_order = receivable[rec_start]['order']
            rec_end = rec_start
            while rec_end < len(receivable) - 1:
                if receivable[rec_end+1]['by'] != rec or receivable[rec_end+1]['order'] != rec_order:
                    break
                rec_end += 1
            rec_cp = 0
            for i in range(rec_start,rec_end+1):
                rec_cp += receivable[i]['amount_cp']

# ok, figure out the total debt to be cancelled
            if pay_cp < rec_cp:
                cancel_cp = pay_cp
            else:
                cancel_cp = rec_cp
            if args.verbose:
                print char, pay, pay_cp, rec_cp
# modify all the payable debts appropiaately
            pay_cancel_cp = cancel_cp
            i = 0
            while True:
                tmp = payable[i]
                cur_cp = tmp['amount_cp']
                cxl_cp = afal.divide_cp(cur_cp, pay_cancel_cp, pay_cp)
                if args.verbose:
                    print char,"to",pay,"was",cur_cp,"cxl",cxl_cp
                if abs(cur_cp - cxl_cp) < 3:
                    if cur_cp != cxl_cp:
                        sys.stderr.write("\nWARNING losing track of a copper or two {by} {to} {lost}\n".format( by=char, to=pay, lost=cur_cp-cxl_cp))
                    afal.delete_debt( {'date': date, 'debt_id':tmp['debt_id'], 'by': char, 'to': pay, 'amount_cp':cur_cp, 'part_of': part_of, 'note':note, 'item':tmp.get('item'), 'verb': 'completely cancelled'})
                    if i == 0:
                        payable = payable[1:]
                        pay_end -= 1
                    else:
                        sys.stderr.write("\nWARNING deleting a debt in the middle\n")
                        i += 1
                else:
                    afal.debt_lower_owed({'date':date, 'debt_id': tmp['debt_id'], 'by': char, 'to': pay, 'amount_cp': cur_cp,
'item': tmp.get('item'), 'part_of': part_of, 'note': note, 'lower_cp': cxl_cp, 'verb': 'cancelled'})
                    i += 1
                pay_cancel_cp -= cxl_cp
                tmp['amount_cp'] -= cxl_cp
                pay_cp -= cur_cp
                if i > pay_end:
                    break
# modify all the receivable debts appropriately
            rec_cancel_cp = cancel_cp
            for i in range ( rec_start, rec_end + 1 ):
                tmp = receivable[i]
                cur_cp = tmp['amount_cp']
                cxl_cp = afal.divide_cp(cur_cp, rec_cancel_cp, rec_cp)
                if args.verbose:
                    print pay,"to",char,"was",cur_cp,"cxl",cxl_cp
                if abs(cur_cp - cxl_cp) < 3:
                    if cur_cp != cxl_cp:
                        sys.stderr.write("\nWARNING losing track of a copper or two {by} {to} {lost}\n".format(by = pay, to = char, lost = cur_cp-cxl_cp))
                    afal.delete_debt({'date': date, 'debt_id': tmp['debt_id'], 'to': char, 'by': pay, 'amount_cp':cur_cp, 'part_of': part_of, 'note':note, 'item': tmp['item'], 'verb': 'completely cancelled'})
                    if i == rec_start:
                        rec_start += 1
                    else:
                        sys.stderr.write("\nWARNING deleting a debt in the middle\n")
                else:
                    afal.debt_lower_owed({'date':date, 'debt_id': tmp['debt_id'], 'by': pay, 'to': char, 'amount_cp': cur_cp,
'item': tmp.get('item'), 'part_of': part_of, 'note': note, 'lower_cp': cxl_cp, 'verb': 'cancelled'})
                rec_cancel_cp -= cxl_cp
                tmp['amount_cp'] -= cxl_cp
                rec_cp -= cur_cp


def do_find(d):
    check_dict(d, must=('name', 'found'), may = ('owner', 'holder', 'note',
 'value', 'date_found', 'date', 'xfrd'))
    e = {}
    e['item'] = d['name']
    e['finder'] = d['found']
    if 'owner' in d:
        e['owner'] = d['owner']
        if 'holder' in d:
            e['holder'] = d['holder']
        else:
            e['holder'] = e['owner']
    else:
        e['owner'] = e['finder']
        e['holder'] = d.get('holder')
    e['note'] = d.get('note')
    e['value_cp'] = afal.str_to_cp(d.get('value'))
    if 'date_found' in d:
        e['date_found'] = d['date_found']
    elif 'date' in d:
        e['date_found'] = d['date']
    else:
        e['date_found'] = afal.party_to_date(d['found'])
    if 'date_xfrd' in d:
        e['date_xfrd'] = d['date_xfrd']
    else:
        e['date_xfrd'] = d.get('xfrd')
    if args.verbose:
        print "Creating item", e
    afal.insert_item(e)


def do_leave(d):
    check_dict(d, must=('date',))
    date = d.pop('date')
    note = d.pop('note',None)
    for char in d:
        afal.char_leave_parties(date, char, note)


def do_journal(d):
    check_dict(d, must=('date','by','note'), may=('to','cash','virtual','part_of'))
    afal.journal(d['date'], d['by'], d.get('to'), afal.str_to_cp(d.get('cash')), afal.str_to_cp(d.get('virtual')), d['note'], d.get('part_of'))


def _check_loop(chars, char, color):
    if char not in chars:
        chars[char] = {'debts':{}}
        for debt in afal.get_char_debts(char, 'Payable'):
            to = debt['to']
            if to in chars[char]['debts']:
                chars[char]['debts'][to] += debt['amount_cp']
            else:
                chars[char]['debts'][to] = debt['amount_cp']
    for to in chars[char]['debts'].keys():
        if to in chars and 'color' in chars[to] and chars[to]['color'] == color:
            return [[char, chars[char]['debts'][to], to]]
        oc = chars[char].get('color')
        chars[char]['color'] = color
        ret = _check_loop(chars, to, color)
        if oc:
            chars[char]['color'] = oc
        else:
            del chars[char]['color']
        if ret:
           if ret[0][0] != ret[-1][2]:
               ret = [[char, chars[char]['debts'][to], to]] + ret
           return ret
    return None


def do_loop(d):
    check_dict(d, must=('date',), may=('note',))
    date = d['date']
    if 'note' in d:
        note = d['note'] + ' with a pebble'
    else:
        note = 'with a pebble'
    cur_color = 1
    chars = {}
    for char in afal.get_characters('Current'):
        loop = _check_loop(chars, char, cur_color)
        if loop:
            m = loop[0][1]
            for i in loop:
                if i[1] < m:
                    m = i[1]
            print "loop: ", afal.cp_to_str(m)
            for i in loop:
                print " ", i[0], 'owes', afal.cp_to_str(i[1]), 'to', i[2]
                if chars[i[0]]['debts'][i[2]] == m:
                   del chars[i[0]]['debts'][i[2]]
                else:
                   chars[i[0]]['debts'][i[2]] -= m
                do_pay({'date': date, 'by': i[0], 'to': i[2], 'amount_cp': m, 'virtual': True, 'note': note})
        cur_color += 1


def do_coin(d):
    check_dict(d, must=('name','copper_equiv'), may=('common', 'abbrev','note'))
    afal.insert_coin(d['name'], d.get('abbrev'), d['copper_equiv'], d.get('common',False), d.get('note'))


def do_commit(d):
    afal.commit()


def do_trade(d):
    # Two possibilities from=, amount= to move cash
    # or item=, for= to exchange items
    if 'item' in d:
        check_dict(d, must = ('date', 'item', 'for'), may=('note', 'part_of'))
        raise ValueError("trade items not implemented")
#        if args.verbose:
#            print "giving item", d
#        afal.change_item(d['date'], d['item'], owner = d['to'], holder = d['to'], part_of = d.get('part_of'))
        return
    check_dict(d, must=('date', 'to', 'by', 'cash', 'for'), may=('for', 'note', 'part_of'))
    if args.verbose:
        print "giving cash", d
    date = d['date']
    by = d['by']
    to = d['to']
    cash = afal.str_to_coins(d['cash'])
    tradefor = afal.str_to_coins(d['for'])
    if cash['value_cp'] != tradefor['value_cp']:
        raise ValueError("unequal trade {c} != {f}".format(c = cash, f = tradefor))
    print "moving cash", d
    text = 'exchanged {{cs}}{c1}{{ce}} for {{cs}}{c2}{{ce}} with {{to}}'.format(c1 = afal.coins_to_str(cash), c2=afal.coins_to_str(tradefor))
    afal.journal(date, by, to, None, cash['value_cp'], text, d.get('part_of'))
    afal.chars_move_cash({'date': date, 'by': by, 'to': to, 'cash': cash, 'note': d.get('note'), 'part_of': d.get('part_of'), 'journal': False})
    afal.chars_move_cash({'date': date, 'by': to, 'to': by, 'cash': tradefor, 'note': d.get('note'), 'part_of': d.get('part_of'), 'journal': False})


def do_cons(d):
    check_dict(d, must=('date',))
    date = d.pop('date')
    wi_char = d.pop('with', afal.party)
    note = d.pop('note',None)
    part_of = d.pop('part_of', None)
    if len(d) == 0 and wi_char != afal.party:
        d = {afal.party: True}
    for by_char in d:
        wi_coins = afal.get_char_money(wi_char)
        wi_q_table = {}
        for i in wi_coins:
            if i['common_use']:
                wi_q_table[i['coin'].format(s='', es='')] = i['quantity']
        by_coins = afal.get_char_money(by_char)
        print "by",by_char, by_coins
        print "with",wi_char, wi_coins, wi_q_table
        by_mv = {'value_cp': 0}
        wi_mv = {'value_cp': 0}
        did = True
        while did:
            did = False
            nxt = []
            print 'start',by_coins
            while len(by_coins) > 0:
                by_coin = by_coins.pop()
                if not by_coin['common_use']:
                    continue
                by_name = by_coin['coin'].format(s='', es='')
                by_fname = by_coin['coin']
                by_q = by_coin['quantity']
                if by_fname in wi_mv:
                    by_q += wi_mv[by_fname]
                if by_q <= 20:
                    continue
                by_cpe = by_coin['copper_equiv']
                wi_name = None
                wi_cpe = 0
                wi_q = 0
                for tmp_cpe in afal.coins_bycpe:
                    if tmp_cpe <= by_cpe or tmp_cpe % by_cpe != 0 or by_cpe * by_q < tmp_cpe:
                        continue
                    for j in afal.coins_bycpe[tmp_cpe]:
                        name = j['coin'].format(s='', es='')
                        if name in wi_q_table and (tmp_cpe > wi_cpe or (tmp_cpe == wi_cpe and wi_q_table[name] > wi_q)):
                            wi_cpe = tmp_cpe
                            wi_name = name
                            wi_fname = j['coin']
                            wi_q = wi_q_table[name]
                if wi_cpe == 0:
                    nxt.append(by_coin)
                    continue
                did = True
                wi_n = min(wi_q, int((by_cpe * by_q) / wi_cpe))
                by_n = int(wi_n * (wi_cpe / by_cpe))
                if wi_n * wi_cpe != by_n * by_cpe:
                    raise ValueError("Huh?  What?")
                print 'has', by_n, by_name, "out of ", by_q, "at", by_cpe, 'for', wi_n, wi_name, "out of", wi_q, "at", wi_cpe
                wi_mv['value_cp'] += wi_n * wi_cpe
                wi_q_table[by_name] = by_n + wi_q_table.get(by_name,0)
                if wi_q_table[wi_name] == wi_n:
                    del wi_q_table[wi_name]
                else:
                    wi_q_table[wi_name] -= wi_n
                wi_mv[wi_fname] = wi_n + wi_mv.get(wi_fname,0)
                if by_fname in wi_mv:
                    tmp = min(by_n, wi_mv[by_fname])
                    wi_mv['value_cp'] -= tmp * by_cpe
                    if wi_mv[by_fname] == tmp:
                        del wi_mv[by_fname]
                    else:
                        wi_mv[by_fname] -= tmp
                    by_n -= tmp
                if by_n:
                    by_mv['value_cp'] += by_n * by_cpe
                    by_mv[by_fname] = by_n + by_mv.get(by_fname,0)
                    if by_coin['quantity'] > by_n:
                        by_coin['quantity'] -= by_n
                        by_coins.append(by_coin)
            print "looping",nxt,did,wi_q_table
            by_coins = nxt
        if by_mv['value_cp'] != wi_mv['value_cp']:
            raise ValueError("What's wrong?")
        if by_mv['value_cp'] > 0:
            if args.verbose:
                print "{by_char} consolidate {by_mv} into {wi_mv} with {wi_char}".format(
 by_char = by_char, by_mv = afal.coins_to_str(by_mv),
 wi_char = wi_char, wi_mv = afal.coins_to_str(wi_mv))
            text = 'traded {{cs}}{c1}{{ce}} for {{cs}}{c2}{{ce}} with {{to}}'.format(c1 = afal.coins_to_str(by_mv), c2 = afal.coins_to_str(wi_mv))
            afal.journal(date, by_char, wi_char, None, by_mv['value_cp'], text, part_of)
            afal.chars_move_cash({'date': date, 'by': by_char, 'to': wi_char, 'cash': by_mv, 'note': note, 'part_of': part_of, 'journal': False})
            afal.chars_move_cash({'date': date, 'by': wi_char, 'to': by_char, 'cash': wi_mv, 'note': note, 'part_of': part_of, 'journal': False})


def do_break(d):
    afal.fini()
    sys.exit(1)


def do_something(d):
    if args.verbose:
        print "doing", d
    doable =  set(d.keys()) & can_do_set
    if len(doable) != 1:
        sys.stderr.write("\nUnknown todo in {d} {doable}\n".format(d = d, doable=doable))
        return

    date = d.get('date')
    if date:
        date = afal.str_to_date(date)
        if do_something.last_date and date < do_something.last_date:
            sys.stderr.write("\nWARNING dates not in chronological order: {now} {then} {doing}\n".format(now= date, then = do_something.last_date, doing = d))
        do_something.last_date = date
    todo = doable.pop()
    del d[todo]
    can_do[todo](d)

do_something.last_date = None

can_do = {
 'break' : do_break,
 'cancel': do_cancel,
 'coin': do_coin,
 'commit': do_commit,
 'cons': do_cons,
 'dividend': do_dividend,
 'find': do_find,
 'give':do_give,
 'journal': do_journal,
 'leave': do_leave,
 'lend':do_lend,
 'loop': do_loop,
 'meet': do_meet,
 'party': do_party,
 'pay': do_pay,
 'sell': do_sell,
 'trade': do_trade,
 'writeoff':do_writeoff }

can_do_set = frozenset(can_do.keys())

parser = argparse.ArgumentParser("read transactions from a file and do them")
parser.add_argument("--verbose", "-v", help="print progress messages", action='store_true', default=False)
parser.add_argument("file", help="file to read", nargs='*', default=["bulk.dat"])
args = parser.parse_args()

for filename in args.file:
    afal.parse_file(open(filename), do_something, dict())
afal.fini()
