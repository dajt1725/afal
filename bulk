#!/usr/bin/python
import argparse
import afal
import os
import sys
from cStringIO import StringIO

# if may is None, don't check for extra keys at all
def check_dict(d, must = None, may = None):
    """ dict must contain every element in 'must', and may contain elements in 'may'"""

    if may is not None:
        for i in d:
            if i not in must and i not in may:
                sys.stderr.write("\nUnexpected key {i} found in dict {d} only expected must={must}, may={may}\n".format(i = i, d = d, must = must, may = may))
                raise NameError("Unexpected key '"+i+"'")

    for i in must:
        if not i in d:
            sys.stderr.write("\nMissing key {i} in dict {d} expected must={must}\n".format(i = i, d = d, must = must))
            raise NameError("Missing key '"+i+"'")



def do_meet(d):
    check_dict(d, must = ('name', 'status', 'date'), may = ('alignment', 'association',
'characteristics', 'class', 'hidden_note', 'equipment', 'fullname', 'note',
 'player', 'race', 'picture', 'large_picture', 'cash', 'gender'))
    e = {}
    for i in ('name', 'status', 'date', 'alignment', 'association', 'characteristics',
 'class', 'hidden_note', 'equipment', 'fullname', 'note', 'player',
 'race', 'picture', 'large_picture', 'gender'):
        e[i] = d.get(i)
    if 'cash' in d:
        e['cash'] = d['cash']
    if args.verbose:
        afal.pw("Creating character", e, max = 130)
    afal.insert_character(e)


def do_party(d):
    check_dict(d, must = ('name', 'type', 'date'))
    e = {}
    e['name'] = d.pop('name')
    e['type'] = d.pop('type')
    e['date'] = d.pop('date')
    if 'note' in d:
        e['note'] = d.pop('note')
    e['members'] = {}
    for c in d:
        e['members'][c] = d[c]
    if args.verbose:
        afal.pw("creating party", e, max = 130)
    afal.insert_party(e)


def do_give(d):
    # Two possibilities from=, amount= to move cash
    # or item= to give an item
    if 'item' in d:
        check_dict(d, must = ('date', 'to', 'item'), may = ('holder', 'journal', 'note', 'part_of'))
        if args.verbose:
            afal.pw("giving item", d, max = 130)
        afal.change_item(d['date'], d['item'], owner = d['to'], holder = d.get('holder',d['to']), part_of = d.get('part_of'))
        return

    if 'cash' in d:
        check_dict(d, must = ('date', 'to', 'by', 'cash'), may = ('for', 'note', 'part_of'))
        d['cash'] = afal.str_to_coins(d['cash'])
    else:
        check_dict(d, must = ('date', 'to', 'by', 'amount'), may = ('for', 'note', 'part_of'))
        d['amount_cp'] = afal.str_to_cp(d.pop('amount'))
    afal.chars_move_cash(d)


def do_lend(d):
    date = d['date']
    to = d['to']
    part_of = d.get('part_of')
    if 'item' in d:
        check_dict(d, must = ('date', 'to', 'item'), may = ('note', 'part_of'))
        if args.verbose:
            afal.pw("lending item", d, max = 130)
        afal.change_item(date, d['item'], holder = to, part_of = part_of)
        return

    check_dict(d, must = ('date', 'to', 'by', 'amount'), may = ('virtual', 'for', 'note', 'part_of', 'journal'))
    if args.verbose:
        afal.pw("lending cash", d, max = 130)
    by = d['by']
    amount_cp = afal.str_to_cp(d['amount'])
    party_data = afal.get_party_data(by)
    lenders = party_data['members']
    shares = sum(lenders.values())
    if shares == 1:
        even_cp = amount_cp
    else:
        share_mult = 1
        for share in lenders.values():
            if share > 0 and 1/share > share_mult:
                share_mult = int(1/share)
        even_cp = shares * share_mult * int(amount_cp/(shares*share_mult))
        even_cp = int(even_cp)
        if even_cp != amount_cp:
           sys.stdout.write("Note: Even shares would be lending {even} not {amount} for shares of {even_shares} with {leftover} unaccounted for in {d}\n".format(
even = afal.cp_to_str(even_cp), amount = afal.cp_to_str(amount_cp), even_shares = afal.cp_to_str(int(even_cp/shares)), leftover = afal.cp_to_str(amount_cp-even_cp), d = d))
    if len(lenders) > 1 and d.get('journal', True):
        text = "{each}lent {virtual} to {to}"
        if d.get('note'):
            text += ' ' + d['note']
        tmp = afal.journal(date, by, to, None, amount_cp, text, part_of )
        if part_of is None:
            part_of = tmp
    journaled = {}
    journ_by = {}
    for by in lenders:
        share = float(lenders[by])
        if share == 0.0:
            continue
        share_cp = afal.divide_cp(share, amount_cp, shares)
        amount_cp -= share_cp
        shares -= share
        if by == to:
            text = "noted a self-debt of {virtual}"
            totmp = None
        else:
            text = "{each}lent {virtual} to {to}"
            totmp = to
        fer = " for "
        if share != 1.0:
            text += fer + afal.share_to_str(share) + " share"
            fer = " of "
        if d.get('for'):
            text += fer + d['for']
        if d.get('note'):
            text += ' ' + d['note']
        if text in journaled:
            afal.journal_add_by(journaled[text], by)
        else:
            journaled[text] = afal.journal(date, by, totmp, None, share_cp, text, part_of)

        if totmp is not None:
            afal.insert_debt({'date': date, 'by': by, 'to': to,
 'amount_cp': share_cp, 'share': share, 'item': d.get('for')})
            if 'virtual' not in d:
                afal.chars_move_cash({'date': date, 'by': by, 'to': to, 'amount_cp': share_cp, 'part_of': part_of, 'journal': d.get('journal', True), 'journ_by': journ_by})


def do_sell(d):
    check_dict(d, must = ('date', 'to', 'item'), may = ('cash', 'debt', 'note', 'part_of', 'virtual'))
    date = d['date']
    to = d['to']
    cash_cp = afal.str_to_cp(d.get('cash', '0cp'))
    debt_cp = afal.str_to_cp(d.get('debt', '0cp'))
    item = d['item']
    item_data = afal.get_item_data(item)
    note = d.get('note', '')
    part_of = d.get('part_of')
    if item_data is None or len(item_data) < 2 or (cash_cp == 0 and debt_cp == 0):
        sys.stderr.write("\nIgnoring invalid sell command {d}\n".format(d = d))
        return
    seller = item_data['owner']
    if cash_cp > 0:
        t_for = '{cash} cash'
        t_and = ' and '
    else:
        t_for = ''
        t_and = ''
    if debt_cp > 0:
        t_for += t_and + '{virtual} debt'
    text = 'sold {item} to {{to}} for {fer}{note}'.format(item = item, fer = t_for, note = note)
    tmp = afal.journal(date, seller, to, cash_cp, debt_cp, text, part_of)
    if part_of is None:
        part_of = tmp
    afal.change_item(date, item, owner = to, holder = to, value_cp = cash_cp + debt_cp, part_of = part_of )

    if debt_cp > 0:
        do_lend({'by': seller, 'to': to, 'amount': afal.cp_to_str(debt_cp), 'date': date, 'for': item, 'part_of': part_of, 'note': note, 'virtual': True, 'journal': False})
    if 'virtual' not in d and cash_cp > 0:
        do_give({'date': date, 'by': to, 'to': seller, 'cash': d.get('cash'), 'for': item, 'part_of': part_of, 'note': note})


def do_pay(d):
    inexact = False
    item = None
    coins = None
    if 'item' in d:
        check_dict(d, must = ('date', 'to', 'item'), may = ('note', 'part_of'))
        item = d['item']
        item_data = afal.get_item_data(item)
        by = item_data['owner']
        amount_cp = item_data['value_cp']
    elif 'cash' in d:
        check_dict(d, must = ('date', 'by', 'cash', 'to'), may = ('note', 'part_of'))
        by = d['by']
        coins = afal.str_to_coins(d['cash'])
        amount_cp = coins['value_cp']
    elif 'by' in d:        
        check_dict(d, must = ('date', 'by'), may = ('amount_cp', 'amount', 'percent', 'virtual', 'to', 'note', 'part_of'))
        by = d['by']
        if d.get('amount_cp'):
            amount_cp = d['amount_cp']
        elif d.get('amount'):
            amount_cp = afal.str_to_cp(d['amount'])
        elif 'percent' in d:
            amount_cp =  int(float(afal.get_char_data(by)['cash_cp']) * float(d['percent'])/100.0)
            inexact = True
        else:
            amount_cp = afal.get_char_data(by)['cash_cp']
            inexact = True
    else:
        sys.stderr.write("\nIgnoring invalid pay command {d}\n".format(d = d))
        return
    payable = afal.get_char_debts(by, 'Payable')
    if len(payable) == 0:
        sys.stderr.write("\n{date} {by} has not debts to pay\n".format(date = date, by = by))
        return
    if 'to' in d:
        to = d['to']
        ptmp = []
        for i in payable:
            if i['to'] == to:
                ptmp.append(i)
        payable = ptmp
    else:
        to = payable[0]['to']
        for debt in payable[1:]:
           if debt['to'] != to:
               to = 'debts'
               break

    date = d['date']
    shares = 0.0
    owed = 0
    for i in payable:
        shares += i['share']
        owed += i['amount_cp']
    if amount_cp > owed:
        if not inexact:
            if amount_cp - owed < 3:
                sys.stderr.write("\nWARNING: {date} {by} paying {to} lost track of {lost} out of {owed}\n".format( date = date, by = by, to = to, lost = amount_cp - owed, owed = afal.cp_to_str(owed)))
            else:
                sys.stderr.write("\nWARNING: {date} {by} only owes {owed} not {amount} to {to}\n".format(date = date, by = by, owed = afal.cp_to_str(owed), amount = afal.cp_to_str(amount_cp), to = to))
        amount_cp = owed
    if item:
        cash = None
        virtual = amount_cp
        text = 'paid {virtual} {each}to {to} with ' + item
    elif coins is not None:
        cash = amount_cp
        virtual = None
        text = 'paid {cash} {each}to {to} with {cs}' + afal.coins_to_str(coins)+'{ce}'
    else:
        cash = amount_cp
        virtual = None
        text = 'paid {cash} {each}to {to}'
    note = d.get('note')
    if note:
        text += ' ' + note
    part_of = d.get('part_of')
    tmp = afal.journal(date, by, to, cash, virtual, text, part_of)
    if part_of is None:
        part_of = tmp
    topay = {}
    todel = {}
    tolower = {}
    journ_to = {}
    for i in payable:
        this_owed = i['amount_cp']
        this_share = i['share']
        to = i['to']
        this_cp = afal.divide_cp(this_owed, amount_cp, owed)
        if abs(this_cp - this_owed) < 3:
            if this_cp != this_owed:
                sys.stderr.write("\nWARNING: {date} {by} paying {to} lost track of a payable cp or two: {cp} {lost}\n".format(date = date, by = i['by'], to = i['to'], cp = afal.cp_to_str(this_cp), lost = this_cp - this_owed))
            tmp = {'date': date, 'debt_id': i['debt_id'], 'by': i['by'], 'to': i['to'], 'amount_cp': i['amount_cp'], 'item': i.get('item'), 'part_of': part_of, 'note': note, 'verb': 'paid off'}
            if to in todel:
                todel[to].append(tmp)
            else:
                todel[to] = [tmp]
        else:
            tmp = {'date': date, 'debt_id': i['debt_id'], 'by': i['by'], 'to': i['to'], 'amount_cp': i['amount_cp'],
 'part_of': part_of, 'note': note, 'lower_cp': this_cp, 'verb': 'paid'}
            if 'item' in i:
                tmp['item'] = i['item']
            if to in tolower:
                tolower[to].append(tmp)
            else:
                tolower[to] = [tmp]
        if item is None and 'virtual' not in d:
            if to in topay:
                topay[to]['amount_cp'] += this_cp
            else:
                tmp = {'date': date, 'by': by, 'to': to,
 'amount_cp': this_cp, 'journ_to': journ_to}
                if 'to' in d:
                    tmp['journal'] = False
                if coins is not None:
                    tmp['cash'] = coins
                if part_of is not None:
                    tmp['part_of'] = part_of
                if note is not None:
                    tmp['note'] = note
                if len(payable) == 1:
                    if 'item' in i:
                        tmp['item'] = i['item']
                    if 'for' in i:
                        tmp['for'] = i['for']
                topay[to] = tmp
        amount_cp -= this_cp
        owed -= this_owed
        shares -= this_share

    if item is not None:
        part_of = afal.change_item(date, item, owner = to, holder = to, part_of = part_of)
        if to in todel:
            for j in todel[to]:
                j['part_of'] = part_of
        if to in tolower:
            for j in tolower[to]:
                j['part_of'] = part_of
    elif 'virtual' not in d:
        for i in topay:
            part_of = afal.chars_move_cash(topay[i])
            if i in todel:
                for j in todel[i]:
                    j['part_of'] = part_of
                    afal.delete_debt(j)
                del todel[i]
            if i in tolower:
                for j in tolower[i]:
                    j['part_of'] = part_of
                    afal.debt_lower_owed(j)
                del tolower[i]
    for i in todel:
        for j in todel[i]:
            afal.delete_debt(j)
    for i in tolower:
        for j in tolower[i]:
            afal.debt_lower_owed(j)


def do_writeoff(d):
    check_dict(d, must = ('date', ))
    date = d.pop('date')
    part_of_main = d.pop('part_of', None)
    note = d.pop('note', None)
    for char in d:
        payable = afal.get_char_debts(char, 'Payable')
        receivable = afal.get_char_debts(char, 'Receivable')
        if len(payable) > 0 or len(receivable) > 0:
            pay_cp = 0
            for debt in payable:
                pay_cp += debt['amount_cp']
            rec_cp = 0
            for debt in receivable:
                rec_cp += debt['amount_cp']
            if pay_cp > 0 and rec_cp > 0:
                text = 'cancelled {rec} and welshed on {pay} of debts'.format(rec = afal.cp_to_str(rec_cp), pay = afal.cp_to_str(pay_cp))
            elif pay_cp > 0:
                text = 'welshed on {virtual} of debt'
            else:
                text = 'cancelled {virtual} of debt'
            if note:
                text += ' ' + note
            tmp = afal.journal(date, char, None, None, pay_cp + rec_cp, text, part_of_main)
            part_of = tmp if part_of_main is None else part_of_main
            journaled = {}
            for debt in payable:
                afal.delete_debt({'date': date, 'debt_id': debt['debt_id'], 'by': char, 'to': debt['to'], 'amount_cp': debt['amount_cp'], 'item': debt.get('item'), 'part_of': part_of, 'note': note, 'verb': 'welshed on', 'journaled': journaled})
            journaled = {}
            for debt in receivable:
                afal.delete_debt({'date': date, 'debt_id': debt['debt_id'], 'by': debt['by'], 'to': char, 'amount_cp': debt['amount_cp'], 'item': debt.get('item'), 'part_of': part_of, 'note': note, 'verb': 'cancelled', 'journaled': journaled})
        afal.char_leave_parties(date, char, note)


def scale_cash(d, share):
    ret = {}
    for i in d:
        if d[i] * share != int(d[i] * share):
            raise ValueError("cash {n} {i} doesn't scale by {share}".format(n = d[i], i = i, share = share))
        ret[i] = int(d[i] * share)
#    print "scale cash", d, "to", ret, "by", share
    return ret

def do_dividend(d):
    check_dict(d, must = ('date', 'by'), may = ('cash', 'amount', 'note', 'part_of'))
    date = d['date']
    by = d['by']
    party_data = afal.get_party_data(by)
    part_of = d.get('part_of')
    members = party_data['members']
    shares = float(sum(members.values()))
    share_mult = 1
    for share in members.values():
        if share > 0 and 1/share > share_mult:
            share_mult = int(1/share)
    text = "paid a dividend of {cash}"
    if 'amount' in d:
        if 'cash' in d:
            raise ValueError("Can't have both cash and amount")
        amount_cp = afal.str_to_cp(d['amount'])
        cash = None
        even_cash = None
        if shares == 1:
            even_cp = amount_cp
        else:
            even_cp = shares * share_mult * int(amount_cp/(share_mult * shares))
            even_cp = int(even_cp)
            if amount_cp != even_cp:
                text += "(and {cp} to the party)".format(cp = afal.cp_to_str(amount_cp-even_cp))
            text += " split into {sh} shares of {{cs}}{ea}{{ce}} each".format(sh = afal.share_to_str(shares), ea = afal.cp_to_str(int(even_cp/shares)))
    elif 'cash' in d:
        cash = afal.str_to_coins(d['cash'])
        if shares == 1:
            even_cash = cash
            even_cp = cash['value_cp']
        else:
            even_cash = {'value_cp': 0}
            rem_cash = {'value_cp': 0}
            for coin in cash:
                if coin == 'value_cp':
                    continue
                even_coin = int(shares * share_mult * int(cash[coin]/(shares*share_mult)))
                even_cash = afal.coins_add(even_cash, coin, int(even_coin/shares))
                if cash[coin] != even_coin:
                    rem_cash = afal.coins_add(rem_cash, coin, cash[coin] - even_coin)
            if rem_cash['value_cp'] > 0:
                text += "(and {cash} to the party)".format(cash = afal.coins_to_str(rem_cash))
            text += " split into {sh} shares of {{cs}}{ea}{{ce}} each".format(sh = afal.share_to_str(shares), ea = afal.coins_to_str(even_cash))
            even_cp = even_cash['value_cp'] * shares
    else:
        raise ValueError("Need either cash or amount")
    if shares != len(members):
        text += " among {n} party members".format(n = len(members))
    if d.get('note'):
        text += ' ' + d['note']
    tmp = afal.journal(date, by, members.keys(), even_cp, None, text, part_of)
    if part_of is None:
        part_of = tmp
    journ_to = {}
    for char in members:
        share = members[char]
        if share == 0:
            continue
        if even_cash:
            afal.chars_move_cash({'date': date, 'cash': scale_cash(even_cash, share),
'by': by, 'to': char, 'part_of': part_of, 'journ_to': journ_to})
        else:
            share_cp = afal.divide_cp(share, even_cp, shares)
            if args.verbose:
                afal.pw(afal.cp_to_str(share_cp), "to", char, max = 130)
            afal.chars_move_cash({'date': date, 'amount_cp': share_cp,
'by': by, 'to': char, 'part_of': part_of, 'journ_to': journ_to})
            even_cp -= share_cp
            shares -= share


# Divy is like dividend, except that you can specify both cash= and amount=
# and specify specific coins to be given to specific characters
# And it uses a completely different algorithm
# It divides characters into pools by how much they're owed
# then divides up the coins from "cash" so that members of each pool get
# the same number of coins.  To maximize convergance, pools are processed
# in the order of the number of members they have.  If there are leftover
# coins that can't be allocated into a pool, an error is raised.
# Then, the rest of what each pool is owed is filled out of the party's cash
# So, each pool is a dict, containing 'members' a list of character names,
# 'amount_cp', the amount each character is owed, and 'coins', a dict
# of coins.  During creation, they are kept in lists (for different 'coins')
# in a dict by share amount
# which is then flattened into a list sorted by len('members')
def do_divy(d):
    check_dict(d, must = ('date', 'by'))
    text = 'paid a dividend of {cash}'
    share_mult = 1
    journ_to = {}
    pools_by_share = {}
    odd_cp = 0
    s = 'divided '

    date = d.pop('date')
    by = d.pop('by')
    part_of = d.pop('part_of', None)
    note = d.pop('note', None)
    cash = d.pop('cash', None)
    amount = d.pop('amount', None)

    members = afal.get_party_data(by)['members']
    n_members = len(members)
    shares = float(sum(members.values()))
    for share in members.values():
        if share == 0:
            continue
        if 1/share > share_mult:
            share_mult = int(1/share)
        if share not in pools_by_share:
            pools_by_share[share] = []
    for char in members:
        share = members[char]
        if share == 0:
            continue
        if char in d:
            tmp = afal.str_to_coins(d.pop(char))
        else:
            tmp = {'value_cp': 0}
        for i in pools_by_share[share]:
            if i['coins'] == tmp:
                i['members'].append(char)
                char = None
                break
        if char:
            pools_by_share[share].append({'members': [char], 'coins': tmp})
#    print "Debug: pools_by_share", pools_by_share
    if len(d) > 0:
        raise ValueError("Character(s) {d} not in party".format(d = d.keys()))
    if cash:
        coins = afal.str_to_coins(cash)
    else:
        coins = {'value_cp': 0}
    if amount:
        amount_cp = afal.str_to_cp(amount)
    else:
        amount_cp = coins['value_cp']
    if amount_cp == 0:
        raise ValueError("Need either cash or amount")

    if shares != n_members:
        text += " {s}among {n} party members".format(n = n_members, s = s)
        s = ''
    if shares <= 1:
        raise ValueError("Less than two shares?  Unpossible!")

    even_cp = share_mult * int(amount_cp / (share_mult * shares))
    text += " {s}into {sh} shares of {{cs}}{ea}{{ce}} each".format(s = s,
 sh = afal.share_to_str(shares), ea = afal.cp_to_str(even_cp))
    even_cp *= shares
    if even_cp != amount_cp:
        odd_cp = int(amount_cp - even_cp)
        text += " and {{cs}}{n}{{ce}} for the party".format(n = afal.cp_to_str(odd_cp))
        amount_cp = int(even_cp)
    for share in pools_by_share:
        for i in pools_by_share[share]:
            tmp = share * amount_cp / shares
            if tmp != float(int(tmp)):
                raise ValueError("Share didn't come out even")
            tmp = int(tmp) - i['coins']['value_cp']
            if tmp < 0:
                raise ValueError("Share Too large!")
            i['amount_cp'] = tmp

    if note:
        text += ' ' + note
    tmp = afal.journal(date, by, members.keys(), amount_cp + odd_cp, None, text, part_of)
    if part_of is None:
        part_of = tmp

    bank = afal.get_char_money(afal.party)
    for i in bank:
        name = i.get('abbrev', i['coin'])
        if name in coins:
            i['quantity'] -= coins[name]
        for j in pools_by_share:
            for k in pools_by_share[j]:
                for l in k['coins']:
                    if l == 'amount_cp':
                        continue
                    if l == name:
                        i['quantity'] -= k['coins'][l]

    pools_by_size = {}
    for i in pools_by_share:
        for j in pools_by_share[i]:
            tmp = len(j['members'])
            if tmp in pools_by_size:
                pools_by_size[tmp].append(j)
            else:
                pools_by_size[tmp] = [j]

    pools = []
    l = pools_by_size.keys()
    l.sort(reverse = True)
    for i in l:
        for j in pools_by_size[i]:
#            print "Debug: appending ", j
            pools.append(j)

#    print "Debug: pools", pools
    for i in coins:
        if i == 'value_cp':
            continue
        cpe = afal.coins_byname[i]['copper_equiv']
        for j in pools:
            a = j['amount_cp']
            if cpe > a:
                continue
            tmp = len(j['members'])
            n = int(coins[i] / tmp)
            if n == 0:
                continue
            if n * cpe > a:
                n = int(a/cpe)
            if i in j['coins']:
                j['coins'][i] += n
            else:
                j['coins'][i] = n
            coins[i] -= tmp * n
            j['coins']['value_cp'] += tmp * n * cpe
            j['amount_cp'] -= n * cpe
        if coins[i]:
            raise ValueError("coins didn't divide evenly")

    for i in bank:
        cpe = i['copper_equiv']
        if not i['common_use']:
            continue
        for j in pools:
            a = j['amount_cp']
            if cpe > a:
                continue
            tmp = len(j['members'])
            n = int(i['quantity'] / tmp)
            if n == 0:
                continue
            if n * cpe > a:
                n = int(a/cpe)
            name = i.get('abbrev', i['coin'])
            if name in j['coins']:
                j['coins'][name] += n
            else:
                j['coins'][name] = n
            i['quantity'] -= tmp * n
            j['coins']['value_cp'] += tmp * n * cpe
            j['amount_cp'] -= n * cpe

    for i in pools:
        if i['amount_cp']:
            raise ValueError("Need more money: {i} undistributed to {c} after {n}".format(i = afal.cp_to_str(i['amount_cp']), c = i['members'], n = afal.coins_to_str(i['coins'])))
        tmp = afal.coins_to_str(i['coins'])
        for char in i['members']:
            if args.verbose:
                afal.pw(tmp, "to", char, max = 130)
            afal.chars_move_cash({'date': date, 'cash': i['coins'],
'by': by, 'to': char, 'part_of': part_of, 'journ_to': journ_to})


def do_cancel(d):
    check_dict(d, must = ('date', ))
    date = d.pop('date')
    note = d.pop('note', None)
    for char in d:
        payable = afal.get_char_debts(char, 'Payable')
        receivable = afal.get_char_debts(char, 'Receivable')
        if len(payable) == 0 or len(receivable) == 0:
            continue
        part_of = afal.journal(date, char, None, None, None, "cancelled debts")

# payable holds a list of of who we owe money to, sorted by who we owe it to
# receivable holds a list of who owes us money, sorted by who they are
        while len(payable)> 0 and len(receivable)>0:
            if payable[0]['to'] < receivable[0]['by']:
                payable = payable[1:]
                continue
            if receivable[0]['by'] < payable[0]['to']:
                receivable = receivable[1:]
                continue
# if we get here we've found a pair of debts to/from the same person
# Now figure out how many debts of each type we have with that person
            pay = payable[0]['to']
            pay_order = payable[0]['order']
            pay_cp = 0
            pay_end = 0
            while True:
                pay_cp += payable[pay_end]['amount_cp']
                if pay_end == len(payable)-1 or payable[pay_end+1]['to'] != pay or payable[pay_end+1]['order'] != pay_order:
                    break
                pay_end += 1

            rec = receivable[0]['by']
            if rec != pay:
                sys.stderr.write("\nERROR {date} rec {rec} and pay {pay} ids don't match for {char}\n".format(date = date, rec = rec, pay = pay, char = char))
                return
            rec_order = receivable[0]['order']
            rec_cp = 0
            rec_end = 0
            while True:
                rec_cp += receivable[rec_end]['amount_cp']
                if rec_end == len(receivable)-1 or receivable[rec_end+1]['by'] != rec or receivable[rec_end+1]['order'] != rec_order:
                    break
                rec_end += 1

# ok, figure out the total debt to be cancelled
            if pay_cp < rec_cp:
                cancel_cp = pay_cp
            else:
                cancel_cp = rec_cp
            if args.verbose:
                afal.pw(char, pay, pay_cp, rec_cp, max = 130)
# modify all the payable debts appropiaately
            pay_cancel_cp = cancel_cp
            i = 0
            while i <= pay_end:
                tmp = payable[i]
                cur_cp = tmp['amount_cp']
                cxl_cp = afal.divide_cp(cur_cp, pay_cancel_cp, pay_cp)
                if args.verbose:
                    afal.pw(char, "to", pay, "was", cur_cp, "cxl", cxl_cp, max = 130)
                if abs(cur_cp - cxl_cp) < 3:
                    if cur_cp != cxl_cp:
                        sys.stderr.write("\nWARNING {date} losing track of a payable copper or two {by} {cur_cp} {to} {lost}\n".format(date = date, by = char, cur_cp = afal.cp_to_str(cur_cp), to = pay, lost = cur_cp-cxl_cp))
                    afal.delete_debt( {'date': date, 'debt_id': tmp['debt_id'], 'by': char, 'to': pay, 'amount_cp': cur_cp, 'part_of': part_of, 'note': note, 'item': tmp.get('item'), 'verb': 'completely cancelled'})
                    if i == 0:
                        payable = payable[1:]
                        pay_end -= 1
                    else:
                        sys.stderr.write("\nWARNING {date} deleting payable debt {p} at {i}\n".format(date = date, p = payable, i = i))
                        i += 1
                else:
                    afal.debt_lower_owed({'date': date, 'debt_id': tmp['debt_id'], 'by': char, 'to': pay, 'amount_cp': cur_cp,
'item': tmp.get('item'), 'part_of': part_of, 'note': note, 'lower_cp': cxl_cp, 'verb': 'cancelled'})
                    i += 1
                pay_cancel_cp -= cxl_cp
                tmp['amount_cp'] -= cxl_cp
                pay_cp -= cur_cp
# modify all the receivable debts appropriately
            rec_cancel_cp = cancel_cp
            i = 0
            while i <= rec_end:
                tmp = receivable[i]
                cur_cp = tmp['amount_cp']
                cxl_cp = afal.divide_cp(cur_cp, rec_cancel_cp, rec_cp)
                if args.verbose:
                    afal.pw(pay, "to", char, "was", cur_cp, "cxl", cxl_cp, max = 130)
                if abs(cur_cp - cxl_cp) < 3:
                    if cur_cp != cxl_cp:
                        sys.stderr.write("\nWARNING {date} losing track of a receivable copper or two {by} {cp} {to} {lost}\n".format(date = date, by = pay, cp = afal.cp_to_str(cur_cp), to = char, lost = cur_cp-cxl_cp))
                    afal.delete_debt({'date': date, 'debt_id': tmp['debt_id'], 'to': char, 'by': pay, 'amount_cp': cur_cp, 'part_of': part_of, 'note': note, 'item': tmp['item'], 'verb': 'completely cancelled'})
                    if i == 0:
                        receivable = receivable[1:]
                        rec_end -= 1
                    else:
                        sys.stderr.write("\nWARNING {date} deleting debt {d} at {i}\n".format(date = date, d = receivable, i = i))
                        i += 1
                else:
                    afal.debt_lower_owed({'date': date, 'debt_id': tmp['debt_id'], 'by': pay, 'to': char, 'amount_cp': cur_cp,
'item': tmp.get('item'), 'part_of': part_of, 'note': note, 'lower_cp': cxl_cp, 'verb': 'cancelled'})
                    i += 1
                rec_cancel_cp -= cxl_cp
                tmp['amount_cp'] -= cxl_cp
                rec_cp -= cur_cp

def do_find(d):
    check_dict(d, must = ('name', 'found'), may = ('owner', 'holder', 'note',
 'value', 'date_found', 'date', 'xfrd'))
    e = {}
    e['item'] = d['name']
    e['finder'] = d['found']
    if 'owner' in d:
        e['owner'] = d['owner']
        if 'holder' in d:
            e['holder'] = d['holder']
        else:
            e['holder'] = e['owner']
    else:
        e['owner'] = e['finder']
        e['holder'] = d.get('holder')
    e['note'] = d.get('note')
    e['value_cp'] = afal.str_to_cp(d.get('value'))
    if 'date_found' in d:
        e['date_found'] = d['date_found']
    elif 'date' in d:
        e['date_found'] = d['date']
    else:
        e['date_found'] = afal.party_to_date(d['found'])
    if 'date_xfrd' in d:
        e['date_xfrd'] = d['date_xfrd']
    else:
        e['date_xfrd'] = d.get('xfrd')
    if args.verbose:
        afal.pw("Creating item", e, max = 130)
    afal.insert_item(e)


def do_leave(d):
    check_dict(d, must = ('date', ))
    date = d.pop('date')
    note = d.pop('note', None)
    for char in d:
        afal.char_leave_parties(date, char, note)


def do_journal(d):
    check_dict(d, must = ('date', 'by', 'note'), may = ('to', 'cash', 'virtual', 'part_of'))
    afal.journal(d['date'], d['by'], d.get('to'), afal.str_to_cp(d.get('cash')), afal.str_to_cp(d.get('virtual')), d['note'], d.get('part_of'))


def _check_loop(chars, char, color):
    if char not in chars:
        chars[char] = {'debts': {}}
        for debt in afal.get_char_debts(char, 'Payable'):
            to = debt['to']
            if to in chars[char]['debts']:
                chars[char]['debts'][to] += debt['amount_cp']
            else:
                chars[char]['debts'][to] = debt['amount_cp']
    for to in chars[char]['debts'].keys():
        if to in chars and 'color' in chars[to] and chars[to]['color'] == color:
            return [[char, chars[char]['debts'][to], to]]
        oc = chars[char].get('color')
        chars[char]['color'] = color
        ret = _check_loop(chars, to, color)
        if oc:
            chars[char]['color'] = oc
        else:
            del chars[char]['color']
        if ret:
           if ret[0][0] != ret[-1][2]:
               ret = [[char, chars[char]['debts'][to], to]] + ret
           return ret
    return None


def do_loop(d):
    check_dict(d, must = ('date', ), may = ('note', ))
    date = d['date']
    if 'note' in d:
        note = d['note'] + ' with a pebble'
    else:
        note = 'with a pebble'
    cur_color = 1
    chars = {}
    for char in afal.get_characters('Current'):
        loop = _check_loop(chars, char, cur_color)
        if loop:
            m = loop[0][1]
            for i in loop:
                if i[1] < m:
                    m = i[1]
            afal.pw("loop: ", afal.cp_to_str(m), max = 130)
            for i in loop:
                afal.pw(" ", i[0], 'owes', afal.cp_to_str(i[1]), 'to', i[2], max = 130)
                if chars[i[0]]['debts'][i[2]] == m:
                   del chars[i[0]]['debts'][i[2]]
                else:
                   chars[i[0]]['debts'][i[2]] -= m
                do_pay({'date': date, 'by': i[0], 'to': i[2], 'amount_cp': m, 'virtual': True, 'note': note})
        cur_color += 1


def do_coin(d):
    check_dict(d, must = ('name', 'copper_equiv'), may = ('common', 'abbrev', 'note', 'date'))
    afal.insert_coin(d['name'], d.get('abbrev'), d['copper_equiv'], d.get('common', False), d.get('note'))


def do_trade(d):
    # Two possibilities cash=, for= to move cash
    # or item=, for= to exchange items
    part_of = d.get('part_of')
    if 'item' in d:
        check_dict(d, must = ('date', 'item', 'for'), may = ('note', 'part_of'))
        raise ValueError("trade items not implemented")
#        if args.verbose:
#            print "giving item", d
#        afal.change_item(d['date'], d['item'], owner = d['to'], holder = d['to'], part_of = part_of)
        return
    check_dict(d, must = ('date', 'to', 'by'), may = ('cash', 'for', 'note', 'part_of'))
    date = d['date']
    by = d['by']
    to = d['to']
    if 'cash' not in d and 'for' not in d:
        raise ValueError("Need cash or for")
    if 'cash' in d:
        cash = afal.str_to_coins(d['cash'])
        if 'for' not in d:
            tradefor = afal.char_find_money(to, cash['value_cp'])
    if 'for' in d:
        tradefor = afal.str_to_coins(d['for'])
        if 'cash' not in d:
            cash = afal.char_find_money(by, tradefor['value_cp'])

    if cash['value_cp'] != tradefor['value_cp']:
        raise ValueError("unequal trade {c} != {f}".format(c = cash, f = tradefor))
    if args.verbose:
        print "{by} traded {c} for {f} with {to}".format(by = by, c = afal.coins_to_str(cash), f = afal.coins_to_str(tradefor), to = to)
    text = 'exchanged {{cs}}{c1}{{ce}} for {{cs}}{c2}{{ce}} with {{to}}'.format(c1 = afal.coins_to_str(cash), c2 = afal.coins_to_str(tradefor))
    tmp = afal.journal(date, by, to, None, cash['value_cp'], text, part_of)
    if not part_of:
        part_of = tmp
    afal.chars_move_cash({'date': date, 'by': by, 'to': to, 'cash': cash, 'note': d.get('note'), 'part_of': part_of, 'journal': False})
    afal.chars_move_cash({'date': date, 'by': to, 'to': by, 'cash': tradefor, 'note': d.get('note'), 'part_of': part_of, 'journal': False})


def do_cons(d):
    check_dict(d, must = ('date', ))
    date = d.pop('date')
    wi_char = d.pop('with', afal.party)
    note = d.pop('note', None)
    part_of = d.pop('part_of', None)
    if len(d) == 0 and wi_char != afal.party:
        d = {afal.party: True}
    for by_char in d:
        wi_coins = afal.get_char_money(wi_char)
        wi_q_table = {}
        for i in wi_coins:
            if i['common_use']:
                wi_q_table[i['coin'].format(s = '', es = '')] = i['quantity']
        by_coins = afal.get_char_money(by_char)
        afal.pw("by", by_char, by_coins, "with", wi_char, wi_coins, wi_q_table, max = 130)
        by_mv = {'value_cp': 0}
        wi_mv = {'value_cp': 0}
        did = True
        while did:
            did = False
            nxt = []
#            print 'start', by_coins
            while len(by_coins) > 0:
                by_coin = by_coins.pop()
                if not by_coin['common_use']:
                    continue
                by_name = by_coin['coin'].format(s = '', es = '')
                by_fname = by_coin['coin']
                by_q = by_coin['quantity']
                if by_fname in wi_mv:
                    by_q += wi_mv[by_fname]
                if by_q <= 20:
                    continue
                by_cpe = by_coin['copper_equiv']
                wi_name = None
                wi_cpe = 0
                wi_q = 0
                for tmp_cpe in afal.coins_bycpe:
                    if tmp_cpe <= by_cpe or tmp_cpe % by_cpe != 0 or by_cpe * by_q < tmp_cpe:
                        continue
                    for j in afal.coins_bycpe[tmp_cpe]:
                        name = j['coin'].format(s = '', es = '')
                        if name in wi_q_table and (tmp_cpe > wi_cpe or (tmp_cpe == wi_cpe and wi_q_table[name] > wi_q)):
                            wi_cpe = tmp_cpe
                            wi_name = name
                            wi_fname = j['coin']
                            wi_q = wi_q_table[name]
                if wi_cpe == 0:
                    nxt.append(by_coin)
                    continue
                did = True
                wi_n = min(wi_q, int((by_cpe * by_q) / wi_cpe))
                by_n = int(wi_n * (wi_cpe / by_cpe))
                if wi_n * wi_cpe != by_n * by_cpe:
                    raise ValueError("Huh?  What?")
#                print 'has', by_n, by_name, "out of ", by_q, "at", by_cpe, 'for', wi_n, wi_name, "out of", wi_q, "at", wi_cpe
                wi_q_table[by_name] = by_n + wi_q_table.get(by_name, 0)
                if wi_q_table[wi_name] == wi_n:
                    del wi_q_table[wi_name]
                else:
                    wi_q_table[wi_name] -= wi_n
                wi_mv = afal.coins_add(wi_mv, wi_fname, wi_n)
                if by_fname in wi_mv:
                    tmp = min(by_n, wi_mv[by_fname])
                    wi_mv = afal.coins_add(wi_mv, by_fname -tmp)
                    by_n -= tmp
                if by_n:
                    by_mv = afal.coins_add(by_mv, by_fname, by_n)
                    if by_coin['quantity'] > by_n:
                        by_coin['quantity'] -= by_n
                        by_coins.append(by_coin)
#            print "looping", nxt, did, wi_q_table
            by_coins = nxt
        if by_mv['value_cp'] != wi_mv['value_cp']:
            raise ValueError("What's wrong?")
        if by_mv['value_cp'] > 0:
            if args.verbose:
                afal.pw("{by_char} consolidate {by_mv} into {wi_mv} with {wi_char}".format(
 by_char = by_char, by_mv = afal.coins_to_str(by_mv),
 wi_char = wi_char, wi_mv = afal.coins_to_str(wi_mv)), max = 130)
            text = 'traded {{cs}}{c1}{{ce}} for {{cs}}{c2}{{ce}} with {{to}}'.format(c1 = afal.coins_to_str(by_mv), c2 = afal.coins_to_str(wi_mv))
            afal.journal(date, by_char, wi_char, None, by_mv['value_cp'], text, part_of)
            afal.chars_move_cash({'date': date, 'by': by_char, 'to': wi_char, 'cash': by_mv, 'note': note, 'part_of': part_of, 'journal': False})
            afal.chars_move_cash({'date': date, 'by': wi_char, 'to': by_char, 'cash': wi_mv, 'note': note, 'part_of': part_of, 'journal': False})


def do_break(d):
    afal.fini()
    sys.exit(1)


def do_system(d):
    check_dict(d, must = ('cmd', ), may = ('date', ))
    afal.commit()
    sys.stdout.flush()
    os.system(d['cmd'])


def do_something(d):
    if args.verbose:
        afal.pw("doing", d, max = 130)
    doable =  set(d.keys()) & can_do_set
    if len(doable) != 1:
        sys.stderr.write("\nError: Unknown todo in {d} {doable}\n".format(d = d, doable = doable))
        return

    date = d.get('date')
    if date:
        date = afal.str_to_date(date)
        if do_something.last_date and date < do_something.last_date:
            sys.stderr.write("\nWARNING dates not in chronological order: {now} {then} {doing}\n".format(now= date, then = do_something.last_date, doing = d))
        do_something.last_date = date
    todo = doable.pop()
    del d[todo]
    can_do[todo](d)
    if do_something.commit:
        afal.commit()


def do_commit(d):
    if 'on' in d:
        do_something.commit = True
    elif 'off' in d:
        do_something.commit = False
    else:
        afal.commit()


do_something.last_date = None
do_something.commit = False

can_do = {
 'break' : do_break,
 'cancel': do_cancel,
 'coin': do_coin,
 'commit': do_commit,
 'cons': do_cons,
 'dividend': do_dividend,
 'divy': do_divy,
 'find': do_find,
 'give': do_give,
 'journal': do_journal,
 'leave': do_leave,
 'lend': do_lend,
 'loop': do_loop,
 'meet': do_meet,
 'party': do_party,
 'pay': do_pay,
 'sell': do_sell,
 'system': do_system,
 'trade': do_trade,
 'writeoff': do_writeoff }

can_do_set = frozenset(can_do.keys())

parser = argparse.ArgumentParser("read transactions from a file and do them")
parser.add_argument("--verbose", "-v", help = "print progress messages", action = 'store_true', default = False)
parser.add_argument("--command", '-c', help = "single command", default = None)
parser.add_argument("file", help = "file to read", nargs = '*', default = [])
args = parser.parse_args()

if args.command:
    afal.parse_file(StringIO(args.command), do_something, dict())

for filename in args.file:
    afal.parse_file(open(filename), do_something, dict())
afal.fini()
